#include "common.h"
#include "include.h"

 uint8 p=0;
 uint8 Initial=37;
// uint8 m[12]={37,37,37,37,37,37,37,37,37,37,37,37};
// uint8 ml[12]={3,3,3,3,3,3,3,3,3,3,2,3};
// uint8 mr[12]={75,75,75,75,75,75,75,75,75,75,70,75};
 uint8 m[62]={37,37,37,37,37,37,37,37,37,37,
              37,37,37,37,37,37,37,37,37,37,
              37,37,37,37,37,37,37,37,37,37,
              37,37,37,37,37,37,37,37,37,37,
              37,37,37,37,37,37,37,37,37,37,
              37,37,37,37,37,37,37,37,37,37,37,37};
 uint8 ml[62]={3,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,2,3};
 uint8 mr[62]={75,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,70,75};
 uint8 hang[60]={6,12,18,22,27,31,37,44,46,50};
                      // {0,1,2,3,4,5,6,7,8,9,
                      // 10,11,12,13,14,15,16,17,18,19,
                      // 20,21,22,23,24,25,26,27,28,29,
                      // 30,31,32,33,34,35,36,37,38,39,
                      // 40,41,42,43,44,45,46,47,48,49,
                      // 50,51,52,53,54,55,56,57,58,59};
unsigned char lost_l[60]={0};                
unsigned char lost_r[60]={0};
extern uint8 img[CAMERA_H][CAMERA_W];



void edage1(void)
{
  int j_l,j_r,x,p=0;//i_z=0,i_b=0,j=0;
 for(x=9;x>=0;x--)// x=9 同上
   {
         lost_l[x]=0;//左边找不到边界标志位先置1，表示不丢线，逻辑好像有点反~~~~
         lost_r[x]=0;
         p=hang[x];
         for(j_l=Initial;j_l>=0;j_l--)//先固定行，然后改变列，从中间向两边找黑色的点。图像一共80行，理论中心是40，实测大概在37左右，故Initial=37。先找左边
         {                           //所以j_l--
           if(img[p][j_l]==BLACK1)//小于阈值就是黑的的点，即边界。今年硬件二值化，直接等于黑色的点就行（黑白点，已经宏定义好了）
           {
             if(j_l==0)//因为人为加了边框，所以必然能找到左右边界，所以认为左边界所在的列小于2就算左丢线
             {
               ml[x]=ml[x+1];
               lost_l[x]=1;//置1，表示丢线
             }
             else
             {
               ml[x]=j_l; //把找到的黑色点所在的列记为左边界
               img[p][j_l]=255;// 把找到的左边界点变成纯白色，方便在上位机观察找的对不对（今年图像只有黑色和白色，不宜变成纯白，可将254变小一点，直到在上位机上能看清）
             }
           break;
           }
           else;             
         }
         for(j_r=Initial;j_r<=79;j_r++)//再找右边界，应该是j_r++。由于图像的原因，有效的只有77行，j_r<=77
         {
           if(img[p][j_r]==BLACK1)
           {
            
             if(j_r==79)
             {
               mr[x]=mr[x+1];
               lost_r[x]=1;
             }
             else
             {
               mr[x]=j_r;
               img[p][j_r]=255;
             }
             break;
           }
           else;
         }

      m[x]=(ml[x]+mr[x])>>1;// 求出当前行的赛道中心
      Initial=m[x];
      img[p][Initial]=0;
   }
}

/*
void boundary_l()
{
  int j_l,x,Initial=37;
  for(j_l=Initial;j_l>=0;j_l--)
  {
    if(img[p][j_l]==BLACK1)
    {
       ml[x]=j_l; 
       img[p][j_l]=255;
      if(j_l<2)
      {
        lost_l[x]=1;
      }
      else
      {
        lost_l[x]=0;
      }
           break;
            //如果找到了左边界，就没必要再向左找下去了，break跳出for循环
           }
           else              
           {
            // ml[x]=ml[x+1];//如果没有找到左边界，就把上一行的左边界给这一行
             lost_l[x]=0;//置0，表示丢线
           }
         }
         j_l++;
         if(j_l==0)
           ml[x]=ml[x+1];
}


void boundary_r()
{
  int j_r,x,Initial=37;
  for(j_r=Initial;j_r>=0;j_r++)
  {
    if(img[p][j_r]==BLACK1)
    {
       mr[x]=j_r; 
       img[p][j_r]=255;
      if(j_r>78)
      {
        lost_r[x]=1;
      }
      else
      {
        lost_r[x]=0;
      }
               break;
             }

           
           else
           {
            // mr[x]=mr[x+1];
             lost_r[x]=0;
           }
         
         j_r--;
         if(j_r==77)
           mr[x]=mr[x+1];
}
}



void boundary(void)
{
  int x,y;
    boundary_l();
    boundary_r();

    m[x]=(ml[x]+mr[x])>>1;
    y=m[x];
    img[p][y]=0;
}





void edage1(void)
{
  boundary();
}
*/