#include "common.h"
#include "include.h"
#include "camera.h"

uint8 p=0;

// uint8 m[12]={37,37,37,37,37,37,37,37,37,37,37,37};
// uint8 ml[12]={3,3,3,3,3,3,3,3,3,3,2,3};
// uint8 mr[12]={75,75,75,75,75,75,75,75,75,75,70,75};
 int8 m[62]={40,40,40,40,40,40,40,40,40,40,
              40,40,40,40,40,40,40,40,40,40,
              40,40,40,40,40,40,40,40,40,40,
              40,40,40,40,40,40,40,40,40,40,
              40,40,40,40,40,40,40,40,40,40,
              40,40,40,40,40,40,40,40,40,40,40,40};
 uint8 ml[62]={3,3,3,3,3,3,3,3,3,3,
               2,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,
               3,3,3,3,3,3,3,3,3,3,2,3};
 uint8 mr[62]={75,75,75,75,75,75,75,75,75,75,
               78,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,
               75,75,75,75,75,75,75,75,75,75,70,75};
 uint8 hang[60]={6,9,13,19,23,27,31,39,46,55};
                       //6,9,13,19,23,27,31,39,46,55
                       //{0,1,2,3,4,5,6,7,8,9,
                       //10,11,12,13,14,15,16,17,18,19,
                       //20,21,22,23,24,25,26,27,28,29,
                       //30,31,32,33,34,35,36,37,38,39,
                       //40,41,42,43,44,45,46,47,48,49,
                       //50,51,52,53,54,55,56,57,58,59};
int decide[3]={0},yuzhi=0,i5;
uint8 buxian[10]={0};
unsigned char lost_l[60]={0};                
unsigned char lost_r[60]={0};
extern uint8 img[CAMERA_H][CAMERA_W];
//绝对值
float abs1(float a)
       {
       if(a<0)
       a=-a;
       return a;
       }


void get_blackline(void)
{
  int j_l,j_r,x,p=0;//i_z=0,i_b=0,j=0;
  uint8 Initial=40,i,j;
  //加边框
 for(i=0;i<=79;i++)
   {
     img[0][i]=BLACK1;
     img[59][i]=BLACK1;
   }
 for(j=0;j<=59;j++)
   {
     img[j][0]=BLACK1;
     img[j][79]=BLACK1;
   }
  
 //开始找边线 
 for(x=9;x>=0;x--)// x=12 同上
   {
         lost_l[x]=0;//左边找不到边界标志位先置1，表示不丢线，逻辑好像有点反~~~~
         lost_r[x]=0;
         p=hang[x];
         for(j_l=Initial;j_l>=0;j_l--)//先固定行，然后改变列，从中间向两边找黑色的点。图像一共80行，理论中心是40，实测大概在37左右，故Initial=37。先找左边
         {                           //所以j_l--
           if(img[p][j_l]==BLACK1)//小于阈值就是黑的的点，即边界。今年硬件二值化，直接等于黑色的点就行（黑白点，已经宏定义好了）
           {
             ml[x]=j_l; //把找到的黑色点所在的列记为左边界
             img[p][j_l]=255;// 把找到的左边界点变成纯白色，方便在上位机观察找的对不对（今年图像只有黑色和白色，不宜变成纯白，可将254变小一点，直到在上位机上能看清）
             if(j_l==0)//因为人为加了边框，所以必然能找到左右边界，所以认为左边界所在的列小于2就算左丢线
             {
             lost_l[x]=1;//置0，表示丢线
             }
             else
             {
              lost_l[x]=0;
             }
             break;//如果找到了左边界，就没必要再向左找下去了，break跳出for循环
           }
           else   ;       
         }
          if(j_l==-1)
           { 
             ml[x]=ml[x+1];//如果没有找到左边界，就把上一行的左边界给这一行
             lost_l[x]=1;//置0，表示丢线
           }
         for(j_r=Initial;j_r<=79;j_r++)//再找右边界，应该是j_r++。由于图像的原因，有效的只有77行，j_r<=77
         {
           if(img[p][j_r]==BLACK1)
           {
             mr[x]=j_r;
            img[p][j_r]=255;
             if(j_r==79)
             {
               lost_r[x]=1;
             }
             else
             {
               lost_r[x]=0;
             }
             break;
           }
           else ;

         }
          if(j_r==80)
          {
             mr[x]=mr[x+1];
             lost_r[x]=1;
          }

     m[x]=(ml[x]+mr[x])>>1;// 求出当前行的赛道中心
     
     //补线
     if((lost_l[x]==1)&&(lost_r[x]==0))// 如果左丢右不丢，即向左的大弯
      {
            if(x>4) buxian[x]=(79-mr[x])/15;// 后五行除以10取整，得到需要补线的值
            
            else buxian[x]=(79-mr[x])/10;//前五行除以5……
            
             m[x]-=buxian[x];//赛道中心减去需要补线的值
      }
      else if((lost_l[x]==0)&&(lost_r[x]==1))//如果左不丢右丢，即向右的大弯
      {
         if(x>4)  buxian[x]=(ml[x]-2)/10;
     
         else buxian[x]=(ml[x]-2)/5;
        
         m[x]+=buxian[x];//这边是加
      }
      else if((lost_l[x]==0)&&(lost_r[x]==0)) m[x]=m[x]; 
      else  m[x]=m[11];
   
      Initial=m[x];
      img[p][Initial]=BLACK1;
      
       //对INITIAL进行优化
         if((m[x]<=30)&&(m[x]>5))//如果求出的赛道中心，在这中间，下一行就在上一个  Initial基础上左移四个点，再左右寻找，下同
           Initial-=4;
         else if (m[x]<=5)
           Initial=5;
         else if ((m[x]>=45)&&(m[x]<74))
           Initial+=4;
         else if (m[x]>=74)
           Initial=75;
         else
           Initial=m[x];
         //initial优化结束
  
   }//行循环结束
 
//找到最前面3行当中，与40相差最大的那个点，作为赛道类型判断的依据 
for(i5=0;i5<3;i5++)
{
  decide[i5]=abs(m[i5]-40);
}
    
if(decide[0]>decide[1])
{
  if(decide[0]>decide[2])
   {
        yuzhi=m[0];
   }
  else
   {
        yuzhi=m[2];
   }
}
else if(decide[1]>decide[2])
   {
        yuzhi=m[1];
   }
else
    {
        yuzhi=m[2]; 
    } 
}




extern uint8 sd_mid;
//                   0,      1,    2,    3,     4,    5,     6,    7,     8,     9  
float mid_quan[10]={0.0,   0.02,  0.10, 0.15,  0.22, 0.21,   0.20,  0.05,  0.03,  0.02};
//float mid_quan[10]={0.0,   0.02,  0.10, 0.15,  0.18, 0.25,   0.20,  0.05,  0.03,  0.02};


void get_mid(void)
{
  uint8 i;
  float ii=0.0;
  for(i=0;i<=9;i++)
  {
    ii=ii+m[i]*mid_quan[i];
  }
  sd_mid=(uint8)ii;

//  sd_mid=(m[3]+m[4]+m[5]+m[6])>>2;
  img[30][sd_mid]=BLACK1;
 // OLED_P6x8Str(90,5,"s:");
 // OLED_Write_Num(100,5,sd_mid);
}






