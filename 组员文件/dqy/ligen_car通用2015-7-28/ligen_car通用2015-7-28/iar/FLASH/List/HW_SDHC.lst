###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        25/Jul/2015  16:58:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\lib\LPLD\HW\HW_SDHC.c
#    Command line =  
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\lib\LPLD\HW\HW_SDHC.c
#        -D LPLD_K60 -D USE_K60F12 -lCN
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\List\
#        -lB
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\List\
#        -o
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4F -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\app\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\common\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\USB\class\
#        -Ol -I "C:\Program Files\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\List\HW_SDHC.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\Obj\HW_SDHC.o
#
###############################################################################

C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\lib\LPLD\HW\HW_SDHC.c
      1          /**
      2           * @file HW_SDHC.c
      3           * @version 3.01[By LPLD]
      4           * @date 2013-10-21
      5           * @brief SDHC底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。 
     21           *
     22           * 版权说明:
     23           *  SDHC模块驱动程序摘取自飞思卡尔MQX底层驱动，部分功能由拉普兰德修改。
     24           *  HW_SDHC.h及HW_SDHC.c内的代码版权归飞思卡尔公司享有。
     25           * 
     26           * 3.01-2013-10-21 修复低容量SD卡无法初始化BUG
     27           */
     28          #include "common.h"
     29          #include "HW_SDHC.h"
     30          
     31          //SD卡信息全局变量

   \                                 In section .bss, align 4
     32          SDCARD_STRUCT_PTR sdcard_ptr;
   \                     sdcard_ptr:
   \   00000000                      DS8 4
     33          
     34          /*
     35           * LPLD_SDHC_InitGPIO
     36           * 初始化SDHC模块相关的GPIO引脚,并使能SDHC寄存器时钟
     37           * 
     38           * 参数:
     39           *    init--PCR寄存器掩码
     40           *
     41           * 输出:
     42           *    无
     43           */

   \                                 In section .text, align 2, keep-with-next
     44          static void LPLD_SDHC_InitGPIO(uint32 init)
     45          {  
     46            PORTE->PCR[0] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D1  */
   \                     LPLD_SDHC_InitGPIO: (+1)
   \   00000000   0xF240 0x4143      MOVW     R1,#+1091
   \   00000004   0x4001             ANDS     R1,R1,R0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0x4004d000
   \   0000000A   0x6011             STR      R1,[R2, #+0]
     47            PORTE->PCR[1] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D0  */
   \   0000000C   0xF240 0x4143      MOVW     R1,#+1091
   \   00000010   0x4001             ANDS     R1,R1,R0
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable8_1  ;; 0x4004d004
   \   00000016   0x6011             STR      R1,[R2, #+0]
     48            PORTE->PCR[2] = init & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* SDHC.CLK */
   \   00000018   0xF410 0x6188      ANDS     R1,R0,#0x440
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0x4004d008
   \   00000020   0x6011             STR      R1,[R2, #+0]
     49            PORTE->PCR[3] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.CMD */
   \   00000022   0xF240 0x4143      MOVW     R1,#+1091
   \   00000026   0x4001             ANDS     R1,R1,R0
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable8_3  ;; 0x4004d00c
   \   0000002C   0x6011             STR      R1,[R2, #+0]
     50            PORTE->PCR[4] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D3  */
   \   0000002E   0xF240 0x4143      MOVW     R1,#+1091
   \   00000032   0x4001             ANDS     R1,R1,R0
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable8_4  ;; 0x4004d010
   \   00000038   0x6011             STR      R1,[R2, #+0]
     51            PORTE->PCR[5] = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D2  */
   \   0000003A   0xF240 0x4143      MOVW     R1,#+1091
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x4004d014
   \   00000044   0x6008             STR      R0,[R1, #+0]
     52          #if defined(CPU_MK60DZ10) || defined(CPU_MK60D10)   
     53            SIM->SCGC3 |= SIM_SCGC3_SDHC_MASK; 
     54          #elif defined(CPU_MK60F12) || defined(CPU_MK60F15)
     55            SIM->SCGC3 |= SIM_SCGC3_ESDHC_MASK;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40048030
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40048030
   \   00000054   0x6008             STR      R0,[R1, #+0]
     56          #endif
     57          }
   \   00000056   0x4770             BX       LR               ;; return
     58          
     59          
     60          /*
     61           * LPLD_SDHC_SetBaudrate
     62           * 设置SDHC波特率
     63           * 
     64           * 参数:
     65           *    clock--模块输入时钟，即g_core_clock*1000，单位Hz
     66           *    baud--SDHC期望时钟频率，单位Hz
     67           *
     68           * 输出:
     69           *    无
     70           */

   \                                 In section .text, align 2, keep-with-next
     71          static void LPLD_SDHC_SetBaudrate(uint32 clock, uint32 baud)
     72          {
   \                     LPLD_SDHC_SetBaudrate: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
     73            uint32 pres, div, min, minpres = 0x80, mindiv = 0x0F;
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x230F             MOVS     R3,#+15
     74            int32  val;
     75            
     76            //找到相近的分频因子
     77            min = (uint32)-1;
   \   00000006   0xF05F 0x36FF      MOVS     R6,#-1
     78            for (pres = 2; pres <= 256; pres <<= 1)
   \   0000000A   0x2402             MOVS     R4,#+2
   \   0000000C   0xE00E             B.N      ??LPLD_SDHC_SetBaudrate_0
     79            {
     80              for (div = 1; div <= 16; div++)
     81              {
     82                val = pres * div * baud - clock;
   \                     ??LPLD_SDHC_SetBaudrate_1: (+1)
   \   0000000E   0xFB05 0xF704      MUL      R7,R5,R4
   \   00000012   0x434F             MULS     R7,R1,R7
   \   00000014   0x1A3F             SUBS     R7,R7,R0
     83                if (val >= 0)
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD404             BMI.N    ??LPLD_SDHC_SetBaudrate_2
     84                {
     85                  if (min > val)
   \   0000001A   0x42B7             CMP      R7,R6
   \   0000001C   0xD202             BCS.N    ??LPLD_SDHC_SetBaudrate_2
     86                  {
     87                    min = val;
   \   0000001E   0x003E             MOVS     R6,R7
     88                    minpres = pres;
   \   00000020   0x0022             MOVS     R2,R4
     89                    mindiv = div;
   \   00000022   0x002B             MOVS     R3,R5
     90                  }
     91                }
     92              }
   \                     ??LPLD_SDHC_SetBaudrate_2: (+1)
   \   00000024   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_SDHC_SetBaudrate_3: (+1)
   \   00000026   0x2D11             CMP      R5,#+17
   \   00000028   0xD3F1             BCC.N    ??LPLD_SDHC_SetBaudrate_1
   \   0000002A   0x0064             LSLS     R4,R4,#+1
   \                     ??LPLD_SDHC_SetBaudrate_0: (+1)
   \   0000002C   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000030   0xD801             BHI.N    ??LPLD_SDHC_SetBaudrate_4
   \   00000032   0x2501             MOVS     R5,#+1
   \   00000034   0xE7F7             B.N      ??LPLD_SDHC_SetBaudrate_3
     93            }
     94            
     95            //禁止SDHC模块时钟
     96            SDHC->SYSCTL &= (~ SDHC_SYSCTL_SDCLKEN_MASK);
   \                     ??LPLD_SDHC_SetBaudrate_4: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   00000044   0x6008             STR      R0,[R1, #+0]
     97            
     98            //修改分频因子
     99            div = SDHC->SYSCTL & (~ (SDHC_SYSCTL_DTOCV_MASK | SDHC_SYSCTL_SDCLKFS_MASK | SDHC_SYSCTL_DVS_MASK));
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0005             MOVS     R5,R0
   \   0000004E   0xF36F 0x1513      BFC      R5,#+4,#+16
    100            SDHC->SYSCTL = div | (SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_SDCLKFS(minpres >> 1) | SDHC_SYSCTL_DVS(mindiv - 1));
   \   00000052   0x01D0             LSLS     R0,R2,#+7
   \   00000054   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   00000058   0x4328             ORRS     R0,R0,R5
   \   0000005A   0x1E59             SUBS     R1,R3,#+1
   \   0000005C   0x0109             LSLS     R1,R1,#+4
   \   0000005E   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0xF450 0x2060      ORRS     R0,R0,#0xE0000
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    101            
    102            //等在时钟稳定
    103            while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_SDSTB_MASK))
   \                     ??LPLD_SDHC_SetBaudrate_5: (+1)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b1024
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0700             LSLS     R0,R0,#+28
   \   00000076   0xD5FA             BPL.N    ??LPLD_SDHC_SetBaudrate_5
    104            {};
    105            
    106            //使能SDHC模块时钟
    107            SDHC->SYSCTL |= SDHC_SYSCTL_SDCLKEN_MASK;
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   00000086   0x6008             STR      R0,[R1, #+0]
    108            SDHC->IRQSTAT |= SDHC_IRQSTAT_DTOE_MASK;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000096   0x6008             STR      R0,[R1, #+0]
    109          }
   \   00000098   0xBCF0             POP      {R4-R7}
   \   0000009A   0x4770             BX       LR               ;; return
    110          
    111          /*
    112           * LPLD_SDHC_IsRunning
    113           * 获取SDHC模块运行状态
    114           * 
    115           * 参数:
    116           *    无
    117           *
    118           * 输出:
    119           *    TRUE--正在运行
    120           *    FALSE--停止运行
    121           */

   \                                 In section .text, align 2, keep-with-next
    122          static boolean LPLD_SDHC_IsRunning(void)
    123          {
    124            return (0 != (SDHC->PRSSTAT & (SDHC_PRSSTAT_RTA_MASK | SDHC_PRSSTAT_WTA_MASK | SDHC_PRSSTAT_DLA_MASK | SDHC_PRSSTAT_CDIHB_MASK | SDHC_PRSSTAT_CIHB_MASK)));
   \                     LPLD_SDHC_IsRunning: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b1024
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF240 0x3107      MOVW     R1,#+775
   \   0000000A   0x4208             TST      R0,R1
   \   0000000C   0xD001             BEQ.N    ??LPLD_SDHC_IsRunning_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??LPLD_SDHC_IsRunning_1
   \                     ??LPLD_SDHC_IsRunning_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IsRunning_1: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    125          }
    126          
    127          /*
    128           * LPLD_SDHC_WaitStatus
    129           * 等待指定状态标志位置位
    130           * 
    131           * 参数:
    132           *    mask--状态标志位掩码
    133           *
    134           * 输出:
    135           *    状态标志
    136           */

   \                                 In section .text, align 2, keep-with-next
    137          static uint32 LPLD_SDHC_WaitStatus(uint32 mask)
    138          {
    139            uint32 result;
    140            do
    141            {
    142              result = SDHC->IRQSTAT & mask;
   \                     LPLD_SDHC_WaitStatus: (+1)
   \                     ??LPLD_SDHC_WaitStatus_0: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x4001             ANDS     R1,R0,R1
    143            }
    144            while (0 == result);
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD0F9             BEQ.N    ??LPLD_SDHC_WaitStatus_0
    145            return result;
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    146          }
    147          
    148          /*
    149           * LPLD_SDHC_Init
    150           * SDHC模块初始化函数
    151           * 
    152           * 参数:
    153           *    coreClk--系y主频，单位Hz
    154           *    baud--SDHC期望时钟频率，单位Hz
    155           *
    156           * 输出:
    157           *    SDHCSTA_OK--状态正常
    158           *    SDHCSTA_NOINIT--驱动未初始化
    159           *    SDHCSTA_NODISK--为插入卡
    160           *    SDHCSTA_PROTECT--卡写保护
    161           */

   \                                 In section .text, align 2, keep-with-next
    162          static SDHCRES LPLD_SDHC_Init(uint32 coreClk, uint32 baud)
    163          {
   \                     LPLD_SDHC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    164            
    165            sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x6108             STR      R0,[R1, #+16]
    166            
    167            //禁用GPIO的SDHC复用功能
    168            LPLD_SDHC_InitGPIO (0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    169            
    170            //复位SDHC模块
    171            SDHC->SYSCTL = SDHC_SYSCTL_RSTA_MASK | SDHC_SYSCTL_SDCLKFS(0x80);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x1008000
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    172            while (SDHC->SYSCTL & SDHC_SYSCTL_RSTA_MASK)
   \                     ??LPLD_SDHC_Init_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x01C0             LSLS     R0,R0,#+7
   \   00000028   0xD4FA             BMI.N    ??LPLD_SDHC_Init_0
    173            { };
    174            
    175            //初始化寄存器值
    176            SDHC->VENDOR = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x400b10c0
   \   00000030   0x6008             STR      R0,[R1, #+0]
    177            SDHC->BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(512);
   \   00000032   0xF45F 0x3081      MOVS     R0,#+66048
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x400b1004
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    178            SDHC->PROCTL = SDHC_PROCTL_EMODE(ESDHC_PROCTL_EMODE_LITTLE) | SDHC_PROCTL_D3CD_MASK;
   \   0000003C   0x2028             MOVS     R0,#+40
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   00000042   0x6008             STR      R0,[R1, #+0]
    179            SDHC->WML = SDHC_WML_RDWML(2) | SDHC_WML_WRWML(1);
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x10002
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable9_5  ;; 0x400b1044
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    180            
    181            //设置SDHC初始化时钟，最好不要超过400kHz
    182            LPLD_SDHC_SetBaudrate (coreClk, baud);
   \   0000004E   0x0029             MOVS     R1,R5
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    183            
    184            //等待
    185            while (SDHC->PRSSTAT & (SDHC_PRSSTAT_CIHB_MASK | SDHC_PRSSTAT_CDIHB_MASK))
   \                     ??LPLD_SDHC_Init_1: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b1024
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF010 0x0F03      TST      R0,#0x3
   \   00000060   0xD1F9             BNE.N    ??LPLD_SDHC_Init_1
    186            { };
    187            
    188            //使能GPIO的SDHC复用
    189            LPLD_SDHC_InitGPIO (0xFFFF);
   \   00000062   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000066   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    190            
    191            //使能各种请求
    192            SDHC->IRQSTAT = 0xFFFF;
   \   0000006A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000072   0x6008             STR      R0,[R1, #+0]
    193            SDHC->IRQSTATEN = SDHC_IRQSTATEN_DEBESEN_MASK | SDHC_IRQSTATEN_DCESEN_MASK | SDHC_IRQSTATEN_DTOESEN_MASK
    194              | SDHC_IRQSTATEN_CIESEN_MASK | SDHC_IRQSTATEN_CEBESEN_MASK | SDHC_IRQSTATEN_CCESEN_MASK | SDHC_IRQSTATEN_CTOESEN_MASK
    195                | SDHC_IRQSTATEN_BRRSEN_MASK | SDHC_IRQSTATEN_BWRSEN_MASK | SDHC_IRQSTATEN_CRMSEN_MASK
    196                  | SDHC_IRQSTATEN_TCSEN_MASK | SDHC_IRQSTATEN_CCSEN_MASK;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x7f00b3
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x400b1034
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    197            
    198            //等待80个初始时钟
    199            SDHC->SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    200            while (SDHC->SYSCTL & SDHC_SYSCTL_INITA_MASK)
   \                     ??LPLD_SDHC_Init_2: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x0100             LSLS     R0,R0,#+4
   \   00000096   0xD4FA             BMI.N    ??LPLD_SDHC_Init_2
    201            { };
    202            
    203            //检查卡是否插入
    204            if (SDHC->PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400b1024
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x03C0             LSLS     R0,R0,#+15
   \   000000A0   0xD505             BPL.N    ??LPLD_SDHC_Init_3
    205            {
    206              sdcard_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000A8   0x6809             LDR      R1,[R1, #+0]
   \   000000AA   0x6108             STR      R0,[R1, #+16]
   \   000000AC   0xE004             B.N      ??LPLD_SDHC_Init_4
    207            }
    208            else
    209            {
    210              sdcard_ptr->STATUS = SDHCSTA_NODISK;
   \                     ??LPLD_SDHC_Init_3: (+1)
   \   000000AE   0x2002             MOVS     R0,#+2
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000B4   0x6809             LDR      R1,[R1, #+0]
   \   000000B6   0x6148             STR      R0,[R1, #+20]
    211            }
    212            SDHC->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??LPLD_SDHC_Init_4: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000C6   0x6008             STR      R0,[R1, #+0]
    213            
    214            return SDHCRES_OK;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    215          }
    216          
    217          /*
    218           * LPLD_SDHC_SendCommand
    219           * 向SD卡发送指定CMD命令
    220           * 
    221           * 参数:
    222           *    command--SDHC命令信息结构体
    223           *
    224           * 输出:
    225           *    SDHCRES--磁盘功能返回值
    226           */

   \                                 In section .text, align 2, keep-with-next
    227          static SDHCRES LPLD_SDHC_SendCommand(ESDHC_COMMAND_STRUCT_PTR command)
    228          {
   \                     LPLD_SDHC_SendCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    229            uint32 xfertyp;
    230            uint32 blkattr;
    231            
    232            //检查命令
    233            xfertyp = command->COMMAND;
   \   00000004   0x6825             LDR      R5,[R4, #+0]
    234            
    235            if (ESDHC_XFERTYP_CMDTYP_RESUME == ((xfertyp & SDHC_XFERTYP_CMDTYP_MASK) >> SDHC_XFERTYP_CMDTYP_SHIFT))
   \   00000006   0xF3C5 0x5081      UBFX     R0,R5,#+22,#+2
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??LPLD_SDHC_SendCommand_0
    236            {
    237              //恢复类型命令必须设置DPSEL位
    238              xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   0000000E   0xF455 0x1500      ORRS     R5,R5,#0x200000
    239            }
    240            
    241            if ((0 != command->BLOCKS) && (0 != command->BLOCKSIZE))
   \                     ??LPLD_SDHC_SendCommand_0: (+1)
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD01E             BEQ.N    ??LPLD_SDHC_SendCommand_1
   \   00000018   0x68E0             LDR      R0,[R4, #+12]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD01B             BEQ.N    ??LPLD_SDHC_SendCommand_1
    242            {
    243              xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   0000001E   0xF455 0x1500      ORRS     R5,R5,#0x200000
    244              if (command->BLOCKS != 1)
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD001             BEQ.N    ??LPLD_SDHC_SendCommand_2
    245              {
    246                //多块传输
    247                xfertyp |= SDHC_XFERTYP_MSBSEL_MASK;
   \   00000028   0xF055 0x0520      ORRS     R5,R5,#0x20
    248              }
    249              if ((uint32)-1 == command->BLOCKS)
   \                     ??LPLD_SDHC_SendCommand_2: (+1)
   \   0000002C   0x68A0             LDR      R0,[R4, #+8]
   \   0000002E   0xF110 0x0F01      CMN      R0,#+1
   \   00000032   0xD107             BNE.N    ??LPLD_SDHC_SendCommand_3
    250              {
    251                //大量传输
    252                blkattr = SDHC_BLKATTR_BLKSIZE(command->BLOCKSIZE) | SDHC_BLKATTR_BLKCNT(0xFFFF);
   \   00000034   0x68E0             LDR      R0,[R4, #+12]
   \   00000036   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   00000038   0x0CC0             LSRS     R0,R0,#+19
   \   0000003A   0xF040 0x407F      ORR      R0,R0,#0xFF000000
   \   0000003E   0xF450 0x007F      ORRS     R0,R0,#0xFF0000
   \   00000042   0xE009             B.N      ??LPLD_SDHC_SendCommand_4
    253              }
    254              else
    255              {
    256                blkattr = SDHC_BLKATTR_BLKSIZE(command->BLOCKSIZE) | SDHC_BLKATTR_BLKCNT(command->BLOCKS);
   \                     ??LPLD_SDHC_SendCommand_3: (+1)
   \   00000044   0x68E0             LDR      R0,[R4, #+12]
   \   00000046   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   00000048   0x0CC0             LSRS     R0,R0,#+19
   \   0000004A   0x68A1             LDR      R1,[R4, #+8]
   \   0000004C   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
    257                xfertyp |= SDHC_XFERTYP_BCEN_MASK;
   \   00000050   0xF055 0x0502      ORRS     R5,R5,#0x2
   \   00000054   0xE000             B.N      ??LPLD_SDHC_SendCommand_4
    258              }
    259            }
    260            else
    261            {
    262              blkattr = 0;
   \                     ??LPLD_SDHC_SendCommand_1: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
    263            }
    264            
    265            //卡移除状态清除
    266            SDHC->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??LPLD_SDHC_SendCommand_4: (+1)
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable10  ;; 0x400b1030
   \   00000066   0x6011             STR      R1,[R2, #+0]
    267            
    268            //等待CMD线空闲
    269            while (SDHC->PRSSTAT & SDHC_PRSSTAT_CIHB_MASK)
   \                     ??LPLD_SDHC_SendCommand_5: (+1)
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0x400b1024
   \   0000006C   0x6809             LDR      R1,[R1, #+0]
   \   0000006E   0x07C9             LSLS     R1,R1,#+31
   \   00000070   0xD4FA             BMI.N    ??LPLD_SDHC_SendCommand_5
    270            { };
    271            
    272            //初始化命令
    273            SDHC->CMDARG = command->ARGUMENT;
   \   00000072   0x6861             LDR      R1,[R4, #+4]
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable10_5  ;; 0x400b1008
   \   00000078   0x6011             STR      R1,[R2, #+0]
    274            SDHC->BLKATTR = blkattr;
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x400b1004
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    275            SDHC->DSADDR = 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable10_6  ;; 0x400b1000
   \   00000086   0x6008             STR      R0,[R1, #+0]
    276            
    277            //发送命令
    278            SDHC->XFERTYP = xfertyp;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable10_7  ;; 0x400b100c
   \   0000008C   0x6005             STR      R5,[R0, #+0]
    279            
    280            //等待响应
    281            if (LPLD_SDHC_WaitStatus (SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK) != SDHC_IRQSTAT_CC_MASK)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable10_8  ;; 0xe0001
   \   00000092   0x.... 0x....      BL       LPLD_SDHC_WaitStatus
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD00B             BEQ.N    ??LPLD_SDHC_SendCommand_6
    282            {
    283              SDHC->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF440 0x2070      ORR      R0,R0,#0xF0000
   \   000000A4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    284              return SDHCRES_ERROR;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE043             B.N      ??LPLD_SDHC_SendCommand_7
    285            }
    286            
    287            //检查卡是否移除
    288            if (SDHC->IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \                     ??LPLD_SDHC_SendCommand_6: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x0600             LSLS     R0,R0,#+24
   \   000000BA   0xD50E             BPL.N    ??LPLD_SDHC_SendCommand_8
    289            {
    290              SDHC->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    291              sdcard_ptr->STATUS = SDHCSTA_NODISK;
   \   000000CC   0x2002             MOVS     R0,#+2
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0x6148             STR      R0,[R1, #+20]
    292              return SDHCRES_NOTRDY;
   \   000000D6   0x2003             MOVS     R0,#+3
   \   000000D8   0xE02F             B.N      ??LPLD_SDHC_SendCommand_7
    293            }
    294            
    295            //获取响应
    296            if (SDHC->IRQSTAT & SDHC_IRQSTAT_CTOE_MASK)
   \                     ??LPLD_SDHC_SendCommand_8: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x03C0             LSLS     R0,R0,#+15
   \   000000E2   0xD509             BPL.N    ??LPLD_SDHC_SendCommand_9
    297            {
    298              SDHC->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    299              return SDHCRES_NONRSPNS;
   \   000000F4   0x2005             MOVS     R0,#+5
   \   000000F6   0xE020             B.N      ??LPLD_SDHC_SendCommand_7
    300            }
    301            if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO))
   \                     ??LPLD_SDHC_SendCommand_9: (+1)
   \   000000F8   0xF415 0x3F40      TST      R5,#0x30000
   \   000000FC   0xD014             BEQ.N    ??LPLD_SDHC_SendCommand_10
    302            {
    303              command->RESPONSE[0] = SDHC->CMDRSP[0];
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x400b1010
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0x6120             STR      R0,[R4, #+16]
    304              if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136))
   \   00000106   0xF415 0x3040      ANDS     R0,R5,#0x30000
   \   0000010A   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000010E   0xD10B             BNE.N    ??LPLD_SDHC_SendCommand_10
    305              {
    306                command->RESPONSE[1] = SDHC->CMDRSP[1];
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x400b1014
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x6160             STR      R0,[R4, #+20]
    307                command->RESPONSE[2] = SDHC->CMDRSP[2];
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x400b1018
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x61A0             STR      R0,[R4, #+24]
    308                command->RESPONSE[3] = SDHC->CMDRSP[3];
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable11_3  ;; 0x400b101c
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x61E0             STR      R0,[R4, #+28]
    309              }
    310            }
    311            SDHC->IRQSTAT |= SDHC_IRQSTAT_CC_MASK;
   \                     ??LPLD_SDHC_SendCommand_10: (+1)
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000136   0x6008             STR      R0,[R1, #+0]
    312            
    313            return SDHCRES_OK;
   \   00000138   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_SendCommand_7: (+1)
   \   0000013A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    314          }
    315          
    316          
    317          /*
    318           * LPLD_SDHC_IOC
    319           * SDHC模块其他控制服务函数
    320           * 
    321           * 参数:
    322           *    cmd--SDHC模块控制命令
    323           *    *param_ptr--控制参数
    324           *
    325           * 输出:
    326           *    SDHCRES--磁盘功能返回值
    327           */

   \                                 In section .text, align 2, keep-with-next
    328          SDHCRES LPLD_SDHC_IOC(uint32 cmd, void *param_ptr)
    329          {
   \                     LPLD_SDHC_IOC: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x000D             MOVS     R5,R1
    330            
    331            ESDHC_COMMAND_STRUCT    command;
    332            boolean                 mem, io, mmc, ceata, mp, hc;
    333            int32                  val;
    334            SDHCRES                 result = SDHCRES_OK;
   \   00000008   0x2400             MOVS     R4,#+0
    335            uint32 *             param32_ptr = param_ptr;
    336            
    337            switch (cmd)
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD015             BEQ.N    ??LPLD_SDHC_IOC_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xF000 0x81D3      BEQ.W    ??LPLD_SDHC_IOC_1
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xF000 0x8272      BEQ.W    ??LPLD_SDHC_IOC_2
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xF000 0x81D2      BEQ.W    ??LPLD_SDHC_IOC_3
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xF000 0x81EB      BEQ.W    ??LPLD_SDHC_IOC_4
   \   00000026   0x2806             CMP      R0,#+6
   \   00000028   0xF000 0x8208      BEQ.W    ??LPLD_SDHC_IOC_5
   \   0000002C   0x2807             CMP      R0,#+7
   \   0000002E   0xF000 0x8222      BEQ.W    ??LPLD_SDHC_IOC_6
   \   00000032   0x2893             CMP      R0,#+147
   \   00000034   0xF000 0x82A3      BEQ.W    ??LPLD_SDHC_IOC_7
   \   00000038   0xE2BC             B.N      ??LPLD_SDHC_IOC_8
    338            {
    339            case IO_IOCTL_ESDHC_INIT:  
    340              //初始化SDHC模块
    341              result = LPLD_SDHC_Init (g_core_clock*1000, 400000);
   \                     ??LPLD_SDHC_IOC_0: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable11_4  ;; 0x61a80
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF44F 0x727A      MOV      R2,#+1000
   \   00000048   0x4350             MULS     R0,R2,R0
   \   0000004A   0x.... 0x....      BL       LPLD_SDHC_Init
   \   0000004E   0x0004             MOVS     R4,R0
    342              if (SDHCRES_OK != result)
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xF040 0x82AF      BNE.W    ??LPLD_SDHC_IOC_9
    343              {
    344                break;
    345              }
    346              
    347              mem = FALSE;
   \                     ??LPLD_SDHC_IOC_10: (+1)
   \   00000058   0x2500             MOVS     R5,#+0
    348              io = FALSE;
   \   0000005A   0x2600             MOVS     R6,#+0
    349              mmc = FALSE;
   \   0000005C   0x2700             MOVS     R7,#+0
    350              ceata = FALSE;
   \   0000005E   0xF05F 0x0800      MOVS     R8,#+0
    351              hc = FALSE;
   \   00000062   0xF05F 0x0A00      MOVS     R10,#+0
    352              mp = FALSE;
   \   00000066   0xF05F 0x0900      MOVS     R9,#+0
    353              
    354              //CMD0 - 空闲命令，复位卡
    355              command.COMMAND = ESDHC_CMD0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9000             STR      R0,[SP, #+0]
    356              command.ARGUMENT = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9001             STR      R0,[SP, #+4]
    357              command.BLOCKS = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x9002             STR      R0,[SP, #+8]
    358              result = LPLD_SDHC_SendCommand (&command);
   \   00000076   0xA800             ADD      R0,SP,#+0
   \   00000078   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000007C   0x0004             MOVS     R4,R0
    359              if (result!=SDHCRES_OK)
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x2C00             CMP      R4,#+0
   \   00000082   0xD005             BEQ.N    ??LPLD_SDHC_IOC_11
    360              {
    361                sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000008A   0x6809             LDR      R1,[R1, #+0]
   \   0000008C   0x6148             STR      R0,[R1, #+20]
    362                break;
   \   0000008E   0xE292             B.N      ??LPLD_SDHC_IOC_9
    363              }
    364              
    365              //CMD8 - 发送接口状态，检查是否支持高容量
    366              command.COMMAND = ESDHC_CMD8;
   \                     ??LPLD_SDHC_IOC_11: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x81a0000
   \   00000094   0x9000             STR      R0,[SP, #+0]
    367              command.ARGUMENT = 0x000001AA;
   \   00000096   0xF44F 0x70D5      MOV      R0,#+426
   \   0000009A   0x9001             STR      R0,[SP, #+4]
    368              command.BLOCKS = 0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9002             STR      R0,[SP, #+8]
    369              result = LPLD_SDHC_SendCommand (&command);
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000000A6   0x0004             MOVS     R4,R0
    370              if (result==SDHCRES_ERROR)
   \   000000A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   0x2C01             CMP      R4,#+1
   \   000000AC   0xD105             BNE.N    ??LPLD_SDHC_IOC_12
    371              {
    372                sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000B4   0x6809             LDR      R1,[R1, #+0]
   \   000000B6   0x6148             STR      R0,[R1, #+20]
    373                break;
   \   000000B8   0xE27D             B.N      ??LPLD_SDHC_IOC_9
    374              }
    375              if (result == SDHCRES_OK)
   \                     ??LPLD_SDHC_IOC_12: (+1)
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x2C00             CMP      R4,#+0
   \   000000BE   0xD10C             BNE.N    ??LPLD_SDHC_IOC_13
    376              {
    377                if (command.RESPONSE[0] != command.ARGUMENT)
   \   000000C0   0x9804             LDR      R0,[SP, #+16]
   \   000000C2   0x9901             LDR      R1,[SP, #+4]
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xD006             BEQ.N    ??LPLD_SDHC_IOC_14
    378                {
    379                  sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000CE   0x6809             LDR      R1,[R1, #+0]
   \   000000D0   0x6148             STR      R0,[R1, #+20]
    380                  result = SDHCRES_ERROR;
   \   000000D2   0x2401             MOVS     R4,#+1
    381                  break;
   \   000000D4   0xE26F             B.N      ??LPLD_SDHC_IOC_9
    382                }
    383                hc = TRUE;
   \                     ??LPLD_SDHC_IOC_14: (+1)
   \   000000D6   0xF05F 0x0A01      MOVS     R10,#+1
    384              }
    385              
    386              //CMD5 - 发送操作状态，测试IO
    387              command.COMMAND = ESDHC_CMD5;
   \                     ??LPLD_SDHC_IOC_13: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x5020000
   \   000000DE   0x9000             STR      R0,[SP, #+0]
    388              command.ARGUMENT = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x9001             STR      R0,[SP, #+4]
    389              command.BLOCKS = 0;      
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x9002             STR      R0,[SP, #+8]
    390              result = LPLD_SDHC_SendCommand (&command);
   \   000000E8   0xA800             ADD      R0,SP,#+0
   \   000000EA   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000000EE   0x0004             MOVS     R4,R0
    391              if (result==SDHCRES_ERROR)
   \   000000F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   0x2C01             CMP      R4,#+1
   \   000000F4   0xD105             BNE.N    ??LPLD_SDHC_IOC_15
    392              {
    393                sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000FC   0x6809             LDR      R1,[R1, #+0]
   \   000000FE   0x6148             STR      R0,[R1, #+20]
    394                break;
   \   00000100   0xE259             B.N      ??LPLD_SDHC_IOC_9
    395              }
    396              if (result == SDHCRES_OK)
   \                     ??LPLD_SDHC_IOC_15: (+1)
   \   00000102   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000104   0x2C00             CMP      R4,#+0
   \   00000106   0xD12F             BNE.N    ??LPLD_SDHC_IOC_16
    397              {
    398                if (((command.RESPONSE[0] >> 28) & 0x07) && (command.RESPONSE[0] & 0x300000))
   \   00000108   0x9804             LDR      R0,[SP, #+16]
   \   0000010A   0xF3C0 0x7002      UBFX     R0,R0,#+28,#+3
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD02C             BEQ.N    ??LPLD_SDHC_IOC_17
   \   00000112   0x9804             LDR      R0,[SP, #+16]
   \   00000114   0xF410 0x1F40      TST      R0,#0x300000
   \   00000118   0xD028             BEQ.N    ??LPLD_SDHC_IOC_17
    399                {
    400                  command.COMMAND = ESDHC_CMD5;
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x5020000
   \   0000011E   0x9000             STR      R0,[SP, #+0]
    401                  command.ARGUMENT = 0x300000;
   \   00000120   0xF45F 0x1040      MOVS     R0,#+3145728
   \   00000124   0x9001             STR      R0,[SP, #+4]
    402                  command.BLOCKS = 0;
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x9002             STR      R0,[SP, #+8]
    403                  val = 0;
   \   0000012A   0xF05F 0x0B00      MOVS     R11,#+0
    404                  do
    405                  {
    406                    val++;
   \                     ??LPLD_SDHC_IOC_18: (+1)
   \   0000012E   0xF11B 0x0B01      ADDS     R11,R11,#+1
    407                    if (result = LPLD_SDHC_SendCommand (&command))
   \   00000132   0xA800             ADD      R0,SP,#+0
   \   00000134   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000138   0x0004             MOVS     R4,R0
   \   0000013A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD105             BNE.N    ??LPLD_SDHC_IOC_19
    408                    {
    409                      break;
    410                    }
    411                  } while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < ESDHC_ALARM_FREQUENCY));
   \                     ??LPLD_SDHC_IOC_20: (+1)
   \   00000140   0x9804             LDR      R0,[SP, #+16]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD402             BMI.N    ??LPLD_SDHC_IOC_19
   \   00000146   0xF1BB 0x0F64      CMP      R11,#+100
   \   0000014A   0xDBF0             BLT.N    ??LPLD_SDHC_IOC_18
    412                  if (SDHCRES_OK != result)
   \                     ??LPLD_SDHC_IOC_19: (+1)
   \   0000014C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000014E   0x2C00             CMP      R4,#+0
   \   00000150   0xF040 0x8231      BNE.W    ??LPLD_SDHC_IOC_9
    413                  {
    414                    break;
    415                  }
    416                  if (command.RESPONSE[0] & 0x80000000)
   \                     ??LPLD_SDHC_IOC_21: (+1)
   \   00000154   0x9804             LDR      R0,[SP, #+16]
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD500             BPL.N    ??LPLD_SDHC_IOC_22
    417                  {
    418                    io = TRUE;
   \   0000015A   0x2601             MOVS     R6,#+1
    419                  }
    420                  if (command.RESPONSE[0] & 0x08000000)
   \                     ??LPLD_SDHC_IOC_22: (+1)
   \   0000015C   0x9804             LDR      R0,[SP, #+16]
   \   0000015E   0x0100             LSLS     R0,R0,#+4
   \   00000160   0xD504             BPL.N    ??LPLD_SDHC_IOC_17
    421                  {
    422                    mp = TRUE;
   \   00000162   0xF05F 0x0901      MOVS     R9,#+1
   \   00000166   0xE001             B.N      ??LPLD_SDHC_IOC_17
    423                  }
    424                }
    425              }
    426              else
    427              {
    428                mp = TRUE;
   \                     ??LPLD_SDHC_IOC_16: (+1)
   \   00000168   0xF05F 0x0901      MOVS     R9,#+1
    429              }
    430              
    431              if (mp)
   \                     ??LPLD_SDHC_IOC_17: (+1)
   \   0000016C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000170   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000174   0xF000 0x80C6      BEQ.W    ??LPLD_SDHC_IOC_23
    432              {
    433                //CMD55 - 特殊应用命令，检查MMC卡
    434                command.COMMAND = ESDHC_CMD55;
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable11_8  ;; 0x371a0000
   \   0000017C   0x9000             STR      R0,[SP, #+0]
    435                command.ARGUMENT = 0;
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0x9001             STR      R0,[SP, #+4]
    436                command.BLOCKS = 0;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x9002             STR      R0,[SP, #+8]
    437                if ((result = LPLD_SDHC_SendCommand (&command))==SDHCRES_ERROR)
   \   00000186   0xA800             ADD      R0,SP,#+0
   \   00000188   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000018C   0x0004             MOVS     R4,R0
   \   0000018E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000190   0x2801             CMP      R0,#+1
   \   00000192   0xF000 0x8210      BEQ.W    ??LPLD_SDHC_IOC_9
    438                {
    439                  break;
    440                }
    441                if (result == SDHCRES_NONRSPNS)
   \                     ??LPLD_SDHC_IOC_24: (+1)
   \   00000196   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000198   0x2C05             CMP      R4,#+5
   \   0000019A   0xD154             BNE.N    ??LPLD_SDHC_IOC_25
    442                {
    443                  //如果为MMC 或 CE-ATA 卡
    444                  io = FALSE;
   \   0000019C   0x2600             MOVS     R6,#+0
    445                  mem = FALSE;
   \   0000019E   0x2500             MOVS     R5,#+0
    446                  hc = FALSE;
   \   000001A0   0xF05F 0x0A00      MOVS     R10,#+0
    447                  
    448                  //CMD1 - 发送测试命令，检查高容量支持
    449                  command.COMMAND = ESDHC_CMD1;
   \   000001A4   0xF05F 0x7080      MOVS     R0,#+16777216
   \   000001A8   0x9000             STR      R0,[SP, #+0]
    450                  command.ARGUMENT = 0x40300000;
   \   000001AA   0x.... 0x....      LDR.W    R0,??DataTable11_9  ;; 0x40300000
   \   000001AE   0x9001             STR      R0,[SP, #+4]
    451                  command.BLOCKS = 0;
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x9002             STR      R0,[SP, #+8]
    452                  if (result = LPLD_SDHC_SendCommand (&command))
   \   000001B4   0xA800             ADD      R0,SP,#+0
   \   000001B6   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000001BA   0x0004             MOVS     R4,R0
   \   000001BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xF040 0x81F9      BNE.W    ??LPLD_SDHC_IOC_9
    453                  {
    454                    break;
    455                  }
    456                  if (0x20000000 == (command.RESPONSE[0] & 0x60000000))
   \                     ??LPLD_SDHC_IOC_26: (+1)
   \   000001C4   0x9804             LDR      R0,[SP, #+16]
   \   000001C6   0xF010 0x40C0      ANDS     R0,R0,#0x60000000
   \   000001CA   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   000001CE   0xD101             BNE.N    ??LPLD_SDHC_IOC_27
    457                  {
    458                    hc = TRUE;
   \   000001D0   0xF05F 0x0A01      MOVS     R10,#+1
    459                  }
    460                  mmc = TRUE;
   \                     ??LPLD_SDHC_IOC_27: (+1)
   \   000001D4   0x2701             MOVS     R7,#+1
    461                  
    462                  //CMD39 - 快速IO，检查CE-ATA的CE签名 */
    463                  command.COMMAND = ESDHC_CMD39;
   \   000001D6   0x.... 0x....      LDR.W    R0,??DataTable11_10  ;; 0x27020000
   \   000001DA   0x9000             STR      R0,[SP, #+0]
    464                  command.ARGUMENT = 0x0C00;
   \   000001DC   0xF44F 0x6040      MOV      R0,#+3072
   \   000001E0   0x9001             STR      R0,[SP, #+4]
    465                  command.BLOCKS = 0;
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0x9002             STR      R0,[SP, #+8]
    466                  if (result = LPLD_SDHC_SendCommand (&command))
   \   000001E6   0xA800             ADD      R0,SP,#+0
   \   000001E8   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000001EC   0x0004             MOVS     R4,R0
   \   000001EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F0   0x2800             CMP      R0,#+0
   \   000001F2   0xF040 0x81E0      BNE.W    ??LPLD_SDHC_IOC_9
    467                  {
    468                    break;
    469                  }
    470                  if (0xCE == (command.RESPONSE[0] >> 8) & 0xFF)
   \                     ??LPLD_SDHC_IOC_28: (+1)
   \   000001F6   0x9804             LDR      R0,[SP, #+16]
   \   000001F8   0x0A00             LSRS     R0,R0,#+8
   \   000001FA   0x28CE             CMP      R0,#+206
   \   000001FC   0xD101             BNE.N    ??LPLD_SDHC_IOC_29
   \   000001FE   0x2001             MOVS     R0,#+1
   \   00000200   0xE000             B.N      ??LPLD_SDHC_IOC_30
   \                     ??LPLD_SDHC_IOC_29: (+1)
   \   00000202   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IOC_30: (+1)
   \   00000204   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000206   0x2800             CMP      R0,#+0
   \   00000208   0xD07C             BEQ.N    ??LPLD_SDHC_IOC_23
    471                  {
    472                    //CMD39 - 快速IO，检查CE-ATA的AA签名 */
    473                    command.COMMAND = ESDHC_CMD39;
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable11_10  ;; 0x27020000
   \   0000020E   0x9000             STR      R0,[SP, #+0]
    474                    command.ARGUMENT = 0x0D00;
   \   00000210   0xF44F 0x6050      MOV      R0,#+3328
   \   00000214   0x9001             STR      R0,[SP, #+4]
    475                    command.BLOCKS = 0;
   \   00000216   0x2000             MOVS     R0,#+0
   \   00000218   0x9002             STR      R0,[SP, #+8]
    476                    if (result = LPLD_SDHC_SendCommand (&command))
   \   0000021A   0xA800             ADD      R0,SP,#+0
   \   0000021C   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000220   0x0004             MOVS     R4,R0
   \   00000222   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000224   0x2800             CMP      R0,#+0
   \   00000226   0xF040 0x81C6      BNE.W    ??LPLD_SDHC_IOC_9
    477                    {
    478                      break;
    479                    }
    480                    if (0xAA == (command.RESPONSE[0] >> 8) & 0xFF)
   \                     ??LPLD_SDHC_IOC_31: (+1)
   \   0000022A   0x9804             LDR      R0,[SP, #+16]
   \   0000022C   0x0A00             LSRS     R0,R0,#+8
   \   0000022E   0x28AA             CMP      R0,#+170
   \   00000230   0xD101             BNE.N    ??LPLD_SDHC_IOC_32
   \   00000232   0x2001             MOVS     R0,#+1
   \   00000234   0xE000             B.N      ??LPLD_SDHC_IOC_33
   \                     ??LPLD_SDHC_IOC_32: (+1)
   \   00000236   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IOC_33: (+1)
   \   00000238   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000023A   0x2800             CMP      R0,#+0
   \   0000023C   0xD062             BEQ.N    ??LPLD_SDHC_IOC_23
    481                    {
    482                      mmc = FALSE;
   \   0000023E   0x2700             MOVS     R7,#+0
    483                      ceata = TRUE;
   \   00000240   0xF05F 0x0801      MOVS     R8,#+1
   \   00000244   0xE05E             B.N      ??LPLD_SDHC_IOC_23
    484                    }
    485                  }
    486                }
    487                else
    488                {
    489                  //如果为SD卡
    490                  //ACMD41 - 发送操作状态
    491                  command.COMMAND = ESDHC_ACMD41;
   \                     ??LPLD_SDHC_IOC_25: (+1)
   \   00000246   0x.... 0x....      LDR.W    R0,??DataTable11_11  ;; 0x29020000
   \   0000024A   0x9000             STR      R0,[SP, #+0]
    492                  command.ARGUMENT = 0;
   \   0000024C   0x2000             MOVS     R0,#+0
   \   0000024E   0x9001             STR      R0,[SP, #+4]
    493                  command.BLOCKS = 0;
   \   00000250   0x2000             MOVS     R0,#+0
   \   00000252   0x9002             STR      R0,[SP, #+8]
    494                  if (result = LPLD_SDHC_SendCommand (&command))
   \   00000254   0xA800             ADD      R0,SP,#+0
   \   00000256   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000025A   0x0004             MOVS     R4,R0
   \   0000025C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000025E   0x2800             CMP      R0,#+0
   \   00000260   0xD005             BEQ.N    ??LPLD_SDHC_IOC_34
    495                  {
    496                    sdcard_ptr->STATUS = SDHCSTA_NOINIT;
   \   00000262   0x2001             MOVS     R0,#+1
   \   00000264   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000268   0x6809             LDR      R1,[R1, #+0]
   \   0000026A   0x6148             STR      R0,[R1, #+20]
    497                    break;
   \   0000026C   0xE1A3             B.N      ??LPLD_SDHC_IOC_9
    498                  }
    499                  if (command.RESPONSE[0] & 0x300000)
   \                     ??LPLD_SDHC_IOC_34: (+1)
   \   0000026E   0x9804             LDR      R0,[SP, #+16]
   \   00000270   0xF410 0x1F40      TST      R0,#0x300000
   \   00000274   0xD046             BEQ.N    ??LPLD_SDHC_IOC_23
    500                  {
    501                    val = 0;
   \   00000276   0xF05F 0x0B00      MOVS     R11,#+0
    502                    do
    503                    {
    504                      val++;
   \                     ??LPLD_SDHC_IOC_35: (+1)
   \   0000027A   0xF11B 0x0B01      ADDS     R11,R11,#+1
    505                      
    506                      //CMD55 + ACMD41 - 发送OCR
    507                      command.COMMAND = ESDHC_CMD55;
   \   0000027E   0x.... 0x....      LDR.W    R0,??DataTable11_8  ;; 0x371a0000
   \   00000282   0x9000             STR      R0,[SP, #+0]
    508                      command.ARGUMENT = 0;
   \   00000284   0x2000             MOVS     R0,#+0
   \   00000286   0x9001             STR      R0,[SP, #+4]
    509                      command.BLOCKS = 0;
   \   00000288   0x2000             MOVS     R0,#+0
   \   0000028A   0x9002             STR      R0,[SP, #+8]
    510                      if (result = LPLD_SDHC_SendCommand (&command))
   \   0000028C   0xA800             ADD      R0,SP,#+0
   \   0000028E   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000292   0x0004             MOVS     R4,R0
   \   00000294   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000296   0x2800             CMP      R0,#+0
   \   00000298   0xD11D             BNE.N    ??LPLD_SDHC_IOC_36
    511                      {
    512                        break;
    513                      }
    514                      
    515                      command.COMMAND = ESDHC_ACMD41;
   \                     ??LPLD_SDHC_IOC_37: (+1)
   \   0000029A   0x.... 0x....      LDR.W    R0,??DataTable11_11  ;; 0x29020000
   \   0000029E   0x9000             STR      R0,[SP, #+0]
    516                      if (hc)
   \   000002A0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000002A4   0xF1BA 0x0F00      CMP      R10,#+0
   \   000002A8   0xD003             BEQ.N    ??LPLD_SDHC_IOC_38
    517                      {
    518                        command.ARGUMENT = 0x40300000;
   \   000002AA   0x.... 0x....      LDR.W    R0,??DataTable11_9  ;; 0x40300000
   \   000002AE   0x9001             STR      R0,[SP, #+4]
   \   000002B0   0xE002             B.N      ??LPLD_SDHC_IOC_39
    519                      }
    520                      else
    521                      {
    522                        command.ARGUMENT = 0x00300000;
   \                     ??LPLD_SDHC_IOC_38: (+1)
   \   000002B2   0xF45F 0x1040      MOVS     R0,#+3145728
   \   000002B6   0x9001             STR      R0,[SP, #+4]
    523                      }
    524                      command.BLOCKS = 0;
   \                     ??LPLD_SDHC_IOC_39: (+1)
   \   000002B8   0x2000             MOVS     R0,#+0
   \   000002BA   0x9002             STR      R0,[SP, #+8]
    525                      if (result = LPLD_SDHC_SendCommand (&command))
   \   000002BC   0xA800             ADD      R0,SP,#+0
   \   000002BE   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000002C2   0x0004             MOVS     R4,R0
   \   000002C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002C6   0x2800             CMP      R0,#+0
   \   000002C8   0xD105             BNE.N    ??LPLD_SDHC_IOC_36
    526                      {
    527                        break;
    528                      }
    529                    } while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < ESDHC_ALARM_FREQUENCY));
   \                     ??LPLD_SDHC_IOC_40: (+1)
   \   000002CA   0x9804             LDR      R0,[SP, #+16]
   \   000002CC   0x2800             CMP      R0,#+0
   \   000002CE   0xD402             BMI.N    ??LPLD_SDHC_IOC_36
   \   000002D0   0xF1BB 0x0F64      CMP      R11,#+100
   \   000002D4   0xDBD1             BLT.N    ??LPLD_SDHC_IOC_35
    530                    if (SDHCRES_OK != result)
   \                     ??LPLD_SDHC_IOC_36: (+1)
   \   000002D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002D8   0x2C00             CMP      R4,#+0
   \   000002DA   0xF040 0x816C      BNE.W    ??LPLD_SDHC_IOC_9
    531                    {
    532                      break;
    533                    }
    534                    if (val >= ESDHC_ALARM_FREQUENCY)
   \                     ??LPLD_SDHC_IOC_41: (+1)
   \   000002DE   0xF1BB 0x0F64      CMP      R11,#+100
   \   000002E2   0xDB02             BLT.N    ??LPLD_SDHC_IOC_42
    535                    {
    536                      hc = FALSE;
   \   000002E4   0xF05F 0x0A00      MOVS     R10,#+0
   \   000002E8   0xE00C             B.N      ??LPLD_SDHC_IOC_23
    537                    }
    538                    else
    539                    {
    540                      mem = TRUE;
   \                     ??LPLD_SDHC_IOC_42: (+1)
   \   000002EA   0x2501             MOVS     R5,#+1
    541                      if (hc)
   \   000002EC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000002F0   0xF1BA 0x0F00      CMP      R10,#+0
   \   000002F4   0xD006             BEQ.N    ??LPLD_SDHC_IOC_23
    542                      {
    543                        hc = FALSE;
   \   000002F6   0xF05F 0x0A00      MOVS     R10,#+0
    544                        if (command.RESPONSE[0] & 0x40000000)
   \   000002FA   0x9804             LDR      R0,[SP, #+16]
   \   000002FC   0x0040             LSLS     R0,R0,#+1
   \   000002FE   0xD501             BPL.N    ??LPLD_SDHC_IOC_23
    545                        {
    546                          hc = TRUE;
   \   00000300   0xF05F 0x0A01      MOVS     R10,#+1
    547                        }
    548                      }
    549                    }
    550                  }
    551                }
    552              }
    553              if (mmc)
   \                     ??LPLD_SDHC_IOC_23: (+1)
   \   00000304   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000306   0x2F00             CMP      R7,#+0
   \   00000308   0xD004             BEQ.N    ??LPLD_SDHC_IOC_43
    554              {
    555                sdcard_ptr->CARD = ESDHC_CARD_MMC;
   \   0000030A   0x2007             MOVS     R0,#+7
   \   0000030C   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000310   0x6809             LDR      R1,[R1, #+0]
   \   00000312   0x6108             STR      R0,[R1, #+16]
    556              }
    557              if (ceata)
   \                     ??LPLD_SDHC_IOC_43: (+1)
   \   00000314   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000318   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000031C   0xD004             BEQ.N    ??LPLD_SDHC_IOC_44
    558              {
    559                sdcard_ptr->CARD = ESDHC_CARD_CEATA;
   \   0000031E   0x2008             MOVS     R0,#+8
   \   00000320   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000324   0x6809             LDR      R1,[R1, #+0]
   \   00000326   0x6108             STR      R0,[R1, #+16]
    560              }
    561              if (io)
   \                     ??LPLD_SDHC_IOC_44: (+1)
   \   00000328   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000032A   0x2E00             CMP      R6,#+0
   \   0000032C   0xD004             BEQ.N    ??LPLD_SDHC_IOC_45
    562              {
    563                sdcard_ptr->CARD = ESDHC_CARD_SDIO;
   \   0000032E   0x2004             MOVS     R0,#+4
   \   00000330   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000334   0x6809             LDR      R1,[R1, #+0]
   \   00000336   0x6108             STR      R0,[R1, #+16]
    564              }
    565              if (mem)
   \                     ??LPLD_SDHC_IOC_45: (+1)
   \   00000338   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000033A   0x2D00             CMP      R5,#+0
   \   0000033C   0xD00E             BEQ.N    ??LPLD_SDHC_IOC_46
    566              {
    567                sdcard_ptr->CARD = ESDHC_CARD_SD;
   \   0000033E   0x2002             MOVS     R0,#+2
   \   00000340   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000344   0x6809             LDR      R1,[R1, #+0]
   \   00000346   0x6108             STR      R0,[R1, #+16]
    568                if (hc)
   \   00000348   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000034C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000350   0xD004             BEQ.N    ??LPLD_SDHC_IOC_46
    569                {
    570                  sdcard_ptr->CARD = ESDHC_CARD_SDHC;
   \   00000352   0x2003             MOVS     R0,#+3
   \   00000354   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000358   0x6809             LDR      R1,[R1, #+0]
   \   0000035A   0x6108             STR      R0,[R1, #+16]
    571                }
    572              }
    573              if (io && mem)
   \                     ??LPLD_SDHC_IOC_46: (+1)
   \   0000035C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000035E   0x2E00             CMP      R6,#+0
   \   00000360   0xD011             BEQ.N    ??LPLD_SDHC_IOC_47
   \   00000362   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000364   0x2D00             CMP      R5,#+0
   \   00000366   0xD00E             BEQ.N    ??LPLD_SDHC_IOC_47
    574              {
    575                sdcard_ptr->CARD = ESDHC_CARD_SDCOMBO;
   \   00000368   0x2005             MOVS     R0,#+5
   \   0000036A   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000036E   0x6809             LDR      R1,[R1, #+0]
   \   00000370   0x6108             STR      R0,[R1, #+16]
    576                if (hc)
   \   00000372   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000376   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000037A   0xD004             BEQ.N    ??LPLD_SDHC_IOC_47
    577                {
    578                  sdcard_ptr->CARD = ESDHC_CARD_SDHCCOMBO;
   \   0000037C   0x2006             MOVS     R0,#+6
   \   0000037E   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000382   0x6809             LDR      R1,[R1, #+0]
   \   00000384   0x6108             STR      R0,[R1, #+16]
    579                }
    580              }
    581              
    582              //禁用GPIO的SDHC复用
    583              LPLD_SDHC_InitGPIO (0);
   \                     ??LPLD_SDHC_IOC_47: (+1)
   \   00000386   0x2000             MOVS     R0,#+0
   \   00000388   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    584              
    585              //设置SDHC工作状态下的默认波特率
    586              LPLD_SDHC_SetBaudrate (g_core_clock*1000, 25000000);
   \   0000038C   0x.... 0x....      LDR.W    R1,??DataTable11_12  ;; 0x17d7840
   \   00000390   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000394   0x6800             LDR      R0,[R0, #+0]
   \   00000396   0xF44F 0x727A      MOV      R2,#+1000
   \   0000039A   0x4350             MULS     R0,R2,R0
   \   0000039C   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    587              
    588              //使能GPIO的SDHC复用
    589              LPLD_SDHC_InitGPIO (0xFFFF);
   \   000003A0   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000003A4   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    590              
    591              if(result == SDHCRES_OK)
   \   000003A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003AA   0x2C00             CMP      R4,#+0
   \   000003AC   0xD104             BNE.N    ??LPLD_SDHC_IOC_48
    592              {
    593                sdcard_ptr->STATUS = SDHCSTA_OK;
   \   000003AE   0x2000             MOVS     R0,#+0
   \   000003B0   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000003B4   0x6809             LDR      R1,[R1, #+0]
   \   000003B6   0x6148             STR      R0,[R1, #+20]
    594              }
    595              break;
   \                     ??LPLD_SDHC_IOC_48: (+1)
   \   000003B8   0xE0FD             B.N      ??LPLD_SDHC_IOC_9
    596            case IO_IOCTL_ESDHC_SEND_COMMAND:
    597              result = LPLD_SDHC_SendCommand ((ESDHC_COMMAND_STRUCT_PTR)param32_ptr);
   \                     ??LPLD_SDHC_IOC_1: (+1)
   \   000003BA   0x0028             MOVS     R0,R5
   \   000003BC   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000003C0   0x0004             MOVS     R4,R0
    598              break;
   \   000003C2   0xE0F8             B.N      ??LPLD_SDHC_IOC_9
    599            case IO_IOCTL_ESDHC_GET_BAUDRATE:
    600              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_3: (+1)
   \   000003C4   0x2D00             CMP      R5,#+0
   \   000003C6   0xD101             BNE.N    ??LPLD_SDHC_IOC_49
    601              {
    602                result = SDHCRES_ERROR;
   \   000003C8   0x2401             MOVS     R4,#+1
   \   000003CA   0xE016             B.N      ??LPLD_SDHC_IOC_50
    603              }
    604              else
    605              {
    606                //获取波特率
    607                val = ((SDHC->SYSCTL & SDHC_SYSCTL_SDCLKFS_MASK) >> SDHC_SYSCTL_SDCLKFS_SHIFT) << 1;
   \                     ??LPLD_SDHC_IOC_49: (+1)
   \   000003CC   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   000003D0   0x6800             LDR      R0,[R0, #+0]
   \   000003D2   0x09C0             LSRS     R0,R0,#+7
   \   000003D4   0xF410 0x7BFF      ANDS     R11,R0,#0x1FE
    608                val *= ((SDHC->SYSCTL & SDHC_SYSCTL_DVS_MASK) >> SDHC_SYSCTL_DVS_SHIFT) + 1;
   \   000003D8   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   000003DC   0x6800             LDR      R0,[R0, #+0]
   \   000003DE   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   000003E2   0x1C40             ADDS     R0,R0,#+1
   \   000003E4   0xFB00 0xFB0B      MUL      R11,R0,R11
    609                *param32_ptr = (uint32)((g_core_clock*1000 / val));
   \   000003E8   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   000003EC   0x6800             LDR      R0,[R0, #+0]
   \   000003EE   0xF44F 0x717A      MOV      R1,#+1000
   \   000003F2   0x4348             MULS     R0,R1,R0
   \   000003F4   0xFBB0 0xF0FB      UDIV     R0,R0,R11
   \   000003F8   0x6028             STR      R0,[R5, #+0]
    610              }
    611              break;
   \                     ??LPLD_SDHC_IOC_50: (+1)
   \   000003FA   0xE0DC             B.N      ??LPLD_SDHC_IOC_9
    612            case IO_IOCTL_ESDHC_SET_BAUDRATE:
    613              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_4: (+1)
   \   000003FC   0x2D00             CMP      R5,#+0
   \   000003FE   0xD101             BNE.N    ??LPLD_SDHC_IOC_51
    614              {
    615                result = SDHCRES_ERROR;
   \   00000400   0x2401             MOVS     R4,#+1
   \   00000402   0xE01A             B.N      ??LPLD_SDHC_IOC_52
    616              }
    617              else if (0 == (*param32_ptr))
   \                     ??LPLD_SDHC_IOC_51: (+1)
   \   00000404   0x6828             LDR      R0,[R5, #+0]
   \   00000406   0x2800             CMP      R0,#+0
   \   00000408   0xD101             BNE.N    ??LPLD_SDHC_IOC_53
    618              {
    619                result = SDHCRES_ERROR;
   \   0000040A   0x2401             MOVS     R4,#+1
   \   0000040C   0xE015             B.N      ??LPLD_SDHC_IOC_52
    620              }
    621              else
    622              {
    623                if (! LPLD_SDHC_IsRunning ())
   \                     ??LPLD_SDHC_IOC_53: (+1)
   \   0000040E   0x.... 0x....      BL       LPLD_SDHC_IsRunning
   \   00000412   0x2800             CMP      R0,#+0
   \   00000414   0xD110             BNE.N    ??LPLD_SDHC_IOC_54
    624                {
    625                  //禁用GPIO的SDHC复用
    626                  LPLD_SDHC_InitGPIO (0);
   \   00000416   0x2000             MOVS     R0,#+0
   \   00000418   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    627                  
    628                  //设置波特率
    629                  LPLD_SDHC_SetBaudrate (g_core_clock*1000, *param32_ptr);
   \   0000041C   0x6829             LDR      R1,[R5, #+0]
   \   0000041E   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000422   0x6800             LDR      R0,[R0, #+0]
   \   00000424   0xF44F 0x727A      MOV      R2,#+1000
   \   00000428   0x4350             MULS     R0,R2,R0
   \   0000042A   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    630                  
    631                  //使能GPIO的SDHC复用
    632                  LPLD_SDHC_InitGPIO (0xFFFF);
   \   0000042E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000432   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
   \   00000436   0xE000             B.N      ??LPLD_SDHC_IOC_52
    633                }
    634                else
    635                {
    636                  result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_54: (+1)
   \   00000438   0x2401             MOVS     R4,#+1
    637                }
    638              }
    639              break;
   \                     ??LPLD_SDHC_IOC_52: (+1)
   \   0000043A   0xE0BC             B.N      ??LPLD_SDHC_IOC_9
    640            case IO_IOCTL_ESDHC_GET_BUS_WIDTH:
    641              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_5: (+1)
   \   0000043C   0x2D00             CMP      R5,#+0
   \   0000043E   0xD101             BNE.N    ??LPLD_SDHC_IOC_55
    642              {
    643                result = SDHCRES_ERROR;
   \   00000440   0x2401             MOVS     R4,#+1
   \   00000442   0xE017             B.N      ??LPLD_SDHC_IOC_56
    644              }
    645              else
    646              {
    647                //获得SDHC总线宽度
    648                val = (SDHC->PROCTL & SDHC_PROCTL_DTW_MASK) >> SDHC_PROCTL_DTW_SHIFT;
   \                     ??LPLD_SDHC_IOC_55: (+1)
   \   00000444   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   00000448   0x6800             LDR      R0,[R0, #+0]
   \   0000044A   0xF3C0 0x0B41      UBFX     R11,R0,#+1,#+2
    649                if (ESDHC_PROCTL_DTW_1BIT == val)
   \   0000044E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000452   0xD102             BNE.N    ??LPLD_SDHC_IOC_57
    650                {
    651                  *param32_ptr = ESDHC_BUS_WIDTH_1BIT;
   \   00000454   0x2000             MOVS     R0,#+0
   \   00000456   0x6028             STR      R0,[R5, #+0]
   \   00000458   0xE00C             B.N      ??LPLD_SDHC_IOC_56
    652                }
    653                else if (ESDHC_PROCTL_DTW_4BIT == val)
   \                     ??LPLD_SDHC_IOC_57: (+1)
   \   0000045A   0xF1BB 0x0F01      CMP      R11,#+1
   \   0000045E   0xD102             BNE.N    ??LPLD_SDHC_IOC_58
    654                {
    655                  *param32_ptr = ESDHC_BUS_WIDTH_4BIT;
   \   00000460   0x2001             MOVS     R0,#+1
   \   00000462   0x6028             STR      R0,[R5, #+0]
   \   00000464   0xE006             B.N      ??LPLD_SDHC_IOC_56
    656                }
    657                else if (ESDHC_PROCTL_DTW_8BIT == val)
   \                     ??LPLD_SDHC_IOC_58: (+1)
   \   00000466   0xF1BB 0x0F10      CMP      R11,#+16
   \   0000046A   0xD102             BNE.N    ??LPLD_SDHC_IOC_59
    658                {
    659                  *param32_ptr = ESDHC_BUS_WIDTH_8BIT;
   \   0000046C   0x2002             MOVS     R0,#+2
   \   0000046E   0x6028             STR      R0,[R5, #+0]
   \   00000470   0xE000             B.N      ??LPLD_SDHC_IOC_56
    660                }
    661                else
    662                {
    663                  result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_59: (+1)
   \   00000472   0x2401             MOVS     R4,#+1
    664                }
    665              }
    666              break;
   \                     ??LPLD_SDHC_IOC_56: (+1)
   \   00000474   0xE09F             B.N      ??LPLD_SDHC_IOC_9
    667            case IO_IOCTL_ESDHC_SET_BUS_WIDTH:
    668              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_6: (+1)
   \   00000476   0x2D00             CMP      R5,#+0
   \   00000478   0xD101             BNE.N    ??LPLD_SDHC_IOC_60
    669              {
    670                result = SDHCRES_ERROR;
   \   0000047A   0x2401             MOVS     R4,#+1
   \   0000047C   0xE03E             B.N      ??LPLD_SDHC_IOC_61
    671              }
    672              else
    673              {
    674                //设置SDHC总线宽度
    675                if (! LPLD_SDHC_IsRunning ())
   \                     ??LPLD_SDHC_IOC_60: (+1)
   \   0000047E   0x.... 0x....      BL       LPLD_SDHC_IsRunning
   \   00000482   0x2800             CMP      R0,#+0
   \   00000484   0xD139             BNE.N    ??LPLD_SDHC_IOC_62
    676                {
    677                  if (ESDHC_BUS_WIDTH_1BIT == *param32_ptr)
   \   00000486   0x6828             LDR      R0,[R5, #+0]
   \   00000488   0x2800             CMP      R0,#+0
   \   0000048A   0xD10E             BNE.N    ??LPLD_SDHC_IOC_63
    678                  {
    679                    SDHC->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   0000048C   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   00000490   0x6800             LDR      R0,[R0, #+0]
   \   00000492   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000496   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   0000049A   0x6008             STR      R0,[R1, #+0]
    680                    SDHC->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_1BIT);
   \   0000049C   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004A0   0x6800             LDR      R0,[R0, #+0]
   \   000004A2   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004A6   0x6008             STR      R0,[R1, #+0]
   \   000004A8   0xE028             B.N      ??LPLD_SDHC_IOC_61
    681                  }
    682                  else if (ESDHC_BUS_WIDTH_4BIT == *param32_ptr)
   \                     ??LPLD_SDHC_IOC_63: (+1)
   \   000004AA   0x6828             LDR      R0,[R5, #+0]
   \   000004AC   0x2801             CMP      R0,#+1
   \   000004AE   0xD110             BNE.N    ??LPLD_SDHC_IOC_64
    683                  {
    684                    SDHC->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   000004B0   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004B4   0x6800             LDR      R0,[R0, #+0]
   \   000004B6   0xF030 0x0006      BICS     R0,R0,#0x6
   \   000004BA   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004BE   0x6008             STR      R0,[R1, #+0]
    685                    SDHC->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_4BIT);
   \   000004C0   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004C4   0x6800             LDR      R0,[R0, #+0]
   \   000004C6   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000004CA   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004CE   0x6008             STR      R0,[R1, #+0]
   \   000004D0   0xE014             B.N      ??LPLD_SDHC_IOC_61
    686                  }
    687                  else if (ESDHC_BUS_WIDTH_8BIT == *param32_ptr)
   \                     ??LPLD_SDHC_IOC_64: (+1)
   \   000004D2   0x6828             LDR      R0,[R5, #+0]
   \   000004D4   0x2802             CMP      R0,#+2
   \   000004D6   0xD10E             BNE.N    ??LPLD_SDHC_IOC_65
    688                  {
    689                    SDHC->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   000004D8   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004DC   0x6800             LDR      R0,[R0, #+0]
   \   000004DE   0xF030 0x0006      BICS     R0,R0,#0x6
   \   000004E2   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004E6   0x6008             STR      R0,[R1, #+0]
    690                    SDHC->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_8BIT);
   \   000004E8   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004EC   0x6800             LDR      R0,[R0, #+0]
   \   000004EE   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004F2   0x6008             STR      R0,[R1, #+0]
   \   000004F4   0xE002             B.N      ??LPLD_SDHC_IOC_61
    691                  }
    692                  else
    693                  {
    694                    result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_65: (+1)
   \   000004F6   0x2401             MOVS     R4,#+1
   \   000004F8   0xE000             B.N      ??LPLD_SDHC_IOC_61
    695                  }
    696                }
    697                else
    698                {
    699                  result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_62: (+1)
   \   000004FA   0x2401             MOVS     R4,#+1
    700                }
    701              }
    702              break;
   \                     ??LPLD_SDHC_IOC_61: (+1)
   \   000004FC   0xE05B             B.N      ??LPLD_SDHC_IOC_9
    703            case IO_IOCTL_ESDHC_GET_CARD:
    704              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_2: (+1)
   \   000004FE   0x2D00             CMP      R5,#+0
   \   00000500   0xD101             BNE.N    ??LPLD_SDHC_IOC_66
    705              {
    706                result = SDHCRES_ERROR;
   \   00000502   0x2401             MOVS     R4,#+1
   \   00000504   0xE03A             B.N      ??LPLD_SDHC_IOC_67
    707              }
    708              else
    709              {
    710                //等待80个时钟
    711                SDHC->SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \                     ??LPLD_SDHC_IOC_66: (+1)
   \   00000506   0x....             LDR.N    R0,??DataTable8_6  ;; 0x400b102c
   \   00000508   0x6800             LDR      R0,[R0, #+0]
   \   0000050A   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000050E   0x....             LDR.N    R1,??DataTable8_6  ;; 0x400b102c
   \   00000510   0x6008             STR      R0,[R1, #+0]
    712                while (SDHC->SYSCTL & SDHC_SYSCTL_INITA_MASK)
   \                     ??LPLD_SDHC_IOC_68: (+1)
   \   00000512   0x....             LDR.N    R0,??DataTable8_6  ;; 0x400b102c
   \   00000514   0x6800             LDR      R0,[R0, #+0]
   \   00000516   0x0100             LSLS     R0,R0,#+4
   \   00000518   0xD4FB             BMI.N    ??LPLD_SDHC_IOC_68
    713                { };
    714                
    715                //更新并返回卡实际状态
    716                if (SDHC->IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \   0000051A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000051E   0x6800             LDR      R0,[R0, #+0]
   \   00000520   0x0600             LSLS     R0,R0,#+24
   \   00000522   0xD511             BPL.N    ??LPLD_SDHC_IOC_69
    717                {
    718                  SDHC->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \   00000524   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000528   0x6800             LDR      R0,[R0, #+0]
   \   0000052A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000052E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000532   0x6008             STR      R0,[R1, #+0]
    719                  sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   00000534   0x2000             MOVS     R0,#+0
   \   00000536   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000053A   0x6809             LDR      R1,[R1, #+0]
   \   0000053C   0x6108             STR      R0,[R1, #+16]
    720                  sdcard_ptr->STATUS = SDHCSTA_NODISK;
   \   0000053E   0x2002             MOVS     R0,#+2
   \   00000540   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000544   0x6809             LDR      R1,[R1, #+0]
   \   00000546   0x6148             STR      R0,[R1, #+20]
    721                }
    722                if (SDHC->PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \                     ??LPLD_SDHC_IOC_69: (+1)
   \   00000548   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400b1024
   \   0000054A   0x6800             LDR      R0,[R0, #+0]
   \   0000054C   0x03C0             LSLS     R0,R0,#+15
   \   0000054E   0xD50B             BPL.N    ??LPLD_SDHC_IOC_70
    723                {
    724                  if (ESDHC_CARD_NONE == sdcard_ptr->CARD)
   \   00000550   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000554   0x6800             LDR      R0,[R0, #+0]
   \   00000556   0x6900             LDR      R0,[R0, #+16]
   \   00000558   0x2800             CMP      R0,#+0
   \   0000055A   0xD10A             BNE.N    ??LPLD_SDHC_IOC_71
    725                  {
    726                    sdcard_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   0000055C   0x2001             MOVS     R0,#+1
   \   0000055E   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000562   0x6809             LDR      R1,[R1, #+0]
   \   00000564   0x6108             STR      R0,[R1, #+16]
   \   00000566   0xE004             B.N      ??LPLD_SDHC_IOC_71
    727                  }
    728                }
    729                else
    730                {
    731                  sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \                     ??LPLD_SDHC_IOC_70: (+1)
   \   00000568   0x2000             MOVS     R0,#+0
   \   0000056A   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000056E   0x6809             LDR      R1,[R1, #+0]
   \   00000570   0x6108             STR      R0,[R1, #+16]
    732                }
    733                *param32_ptr = sdcard_ptr->CARD;
   \                     ??LPLD_SDHC_IOC_71: (+1)
   \   00000572   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000576   0x6800             LDR      R0,[R0, #+0]
   \   00000578   0x6900             LDR      R0,[R0, #+16]
   \   0000057A   0x6028             STR      R0,[R5, #+0]
    734              }
    735              break;
   \                     ??LPLD_SDHC_IOC_67: (+1)
   \   0000057C   0xE01B             B.N      ??LPLD_SDHC_IOC_9
    736              
    737            case IO_IOCTL_FLUSH_OUTPUT:
    738              //等待传输完成
    739              LPLD_SDHC_WaitStatus (SDHC_IRQSTAT_TC_MASK);
   \                     ??LPLD_SDHC_IOC_7: (+1)
   \   0000057E   0x2002             MOVS     R0,#+2
   \   00000580   0x.... 0x....      BL       LPLD_SDHC_WaitStatus
    740              if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000584   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000588   0x6800             LDR      R0,[R0, #+0]
   \   0000058A   0xF410 0x0FE0      TST      R0,#0x700000
   \   0000058E   0xD008             BEQ.N    ??LPLD_SDHC_IOC_72
    741              {
    742                SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK;
   \   00000590   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000594   0x6800             LDR      R0,[R0, #+0]
   \   00000596   0xF450 0x00E0      ORRS     R0,R0,#0x700000
   \   0000059A   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000059E   0x6008             STR      R0,[R1, #+0]
    743                result = SDHCRES_ERROR;
   \   000005A0   0x2401             MOVS     R4,#+1
    744              }
    745              SDHC->IRQSTAT |= SDHC_IRQSTAT_TC_MASK | SDHC_IRQSTAT_BRR_MASK | SDHC_IRQSTAT_BWR_MASK;
   \                     ??LPLD_SDHC_IOC_72: (+1)
   \   000005A2   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000005A6   0x6800             LDR      R0,[R0, #+0]
   \   000005A8   0xF050 0x0032      ORRS     R0,R0,#0x32
   \   000005AC   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000005B0   0x6008             STR      R0,[R1, #+0]
    746              break;
   \   000005B2   0xE000             B.N      ??LPLD_SDHC_IOC_9
    747            default:
    748              result = SDHCRES_ERROR;
   \                     ??LPLD_SDHC_IOC_8: (+1)
   \   000005B4   0x2401             MOVS     R4,#+1
    749              break;
    750            }
    751            
    752            
    753            return result;
   \                     ??LPLD_SDHC_IOC_9: (+1)
   \   000005B6   0x0020             MOVS     R0,R4
   \   000005B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005BA   0xB009             ADD      SP,SP,#+36
   \   000005BC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    754          }
    755          
    756          /*
    757           * LPLD_SDHC_Read
    758           * SDHC读操作
    759           * 
    760           * 参数:
    761           *    *data_ptr--存储数据地址指针
    762           *    n--待读的数据长度
    763           *
    764           * 输出:
    765           *    SDHCRES--磁盘功能返回值
    766           */

   \                                 In section .text, align 2, keep-with-next
    767          static SDHCSTATUS LPLD_SDHC_Read(uint8 *data_ptr, int32 n)
    768          {
   \                     LPLD_SDHC_Read: (+1)
   \   00000000   0xB410             PUSH     {R4}
    769            uint32 buffer;
    770            int32 remains;
    771            
    772            remains = n;
   \   00000002   0x000A             MOVS     R2,R1
    773            if (((uint32)data_ptr & 0x03) == 0)
   \   00000004   0xF010 0x0303      ANDS     R3,R0,#0x3
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD139             BNE.N    ??LPLD_SDHC_Read_0
   \   0000000C   0xE00D             B.N      ??LPLD_SDHC_Read_1
    774            {    
    775              //数据位字对齐，可以以最快的速度直接从寄存器拷贝
    776              while (remains >= 4)
    777              {
    778                if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
    779                {
    780                  SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
    781                  return SDHCRES_ERROR;
    782                }
    783                
    784                //等待，直到收到的数据达到水印长度或传输完成
    785                while ((0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_2: (+1)
   \   0000000E   0x....             LDR.N    R3,??DataTable8_7  ;; 0x400b1024
   \   00000010   0x681B             LDR      R3,[R3, #+0]
   \   00000012   0x051B             LSLS     R3,R3,#+20
   \   00000014   0xD403             BMI.N    ??LPLD_SDHC_Read_3
   \   00000016   0x....             LDR.N    R3,??DataTable8_7  ;; 0x400b1024
   \   00000018   0x681B             LDR      R3,[R3, #+0]
   \   0000001A   0x075B             LSLS     R3,R3,#+29
   \   0000001C   0xD4F7             BMI.N    ??LPLD_SDHC_Read_2
    786                { };
    787                
    788                *((uint32 *)data_ptr) = SDHC->DATPORT;
   \                     ??LPLD_SDHC_Read_3: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable11_13  ;; 0x400b1020
   \   00000022   0x681B             LDR      R3,[R3, #+0]
   \   00000024   0x6003             STR      R3,[R0, #+0]
    789                data_ptr += 4;
   \   00000026   0x1D00             ADDS     R0,R0,#+4
    790                remains -= 4;
   \   00000028   0x1F12             SUBS     R2,R2,#+4
   \                     ??LPLD_SDHC_Read_1: (+1)
   \   0000002A   0x2A04             CMP      R2,#+4
   \   0000002C   0xDB3C             BLT.N    ??LPLD_SDHC_Read_4
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x400b1030
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0xF413 0x0FE0      TST      R3,#0x700000
   \   00000038   0xD0E9             BEQ.N    ??LPLD_SDHC_Read_2
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000044   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE063             B.N      ??LPLD_SDHC_Read_5
    791              }
    792            }
    793            else
    794            {
    795              //非对齐数据，读到临时区域并以字节复制
    796              while (remains >= 4)
    797              {
    798                if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
    799                {
    800                  SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
    801                  return SDHCRES_ERROR;
    802                }
    803                
    804                //等待，直到收到的数据达到水印长度或传输完成
    805                while ((0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_6: (+1)
   \   00000052   0x....             LDR.N    R3,??DataTable8_7  ;; 0x400b1024
   \   00000054   0x681B             LDR      R3,[R3, #+0]
   \   00000056   0x051B             LSLS     R3,R3,#+20
   \   00000058   0xD403             BMI.N    ??LPLD_SDHC_Read_7
   \   0000005A   0x....             LDR.N    R3,??DataTable8_7  ;; 0x400b1024
   \   0000005C   0x681B             LDR      R3,[R3, #+0]
   \   0000005E   0x075B             LSLS     R3,R3,#+29
   \   00000060   0xD4F7             BMI.N    ??LPLD_SDHC_Read_6
    806                { };
    807                
    808                buffer = SDHC->DATPORT;
   \                     ??LPLD_SDHC_Read_7: (+1)
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable11_13  ;; 0x400b1020
   \   00000066   0x681B             LDR      R3,[R3, #+0]
    809                
    810                *data_ptr++ = buffer & 0xFF;
   \   00000068   0x7003             STRB     R3,[R0, #+0]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
    811                *data_ptr++ = (buffer >> 8) & 0xFF;
   \   0000006C   0x0A1C             LSRS     R4,R3,#+8
   \   0000006E   0x7004             STRB     R4,[R0, #+0]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
    812                *data_ptr++ = (buffer >> 16) & 0xFF;
   \   00000072   0x0C1C             LSRS     R4,R3,#+16
   \   00000074   0x7004             STRB     R4,[R0, #+0]
   \   00000076   0x1C40             ADDS     R0,R0,#+1
    813                *data_ptr++ = (buffer >> 24) & 0xFF;
   \   00000078   0x0E1B             LSRS     R3,R3,#+24
   \   0000007A   0x7003             STRB     R3,[R0, #+0]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
    814                
    815                remains -= 4;
   \   0000007E   0x1F12             SUBS     R2,R2,#+4
   \                     ??LPLD_SDHC_Read_0: (+1)
   \   00000080   0x2A04             CMP      R2,#+4
   \   00000082   0xDB11             BLT.N    ??LPLD_SDHC_Read_4
   \   00000084   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x400b1030
   \   00000088   0x681B             LDR      R3,[R3, #+0]
   \   0000008A   0xF413 0x0FE0      TST      R3,#0x700000
   \   0000008E   0xD0E0             BEQ.N    ??LPLD_SDHC_Read_6
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000009A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000A2   0x6008             STR      R0,[R1, #+0]
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE038             B.N      ??LPLD_SDHC_Read_5
    816              }      
    817            }
    818            
    819            if (remains)
   \                     ??LPLD_SDHC_Read_4: (+1)
   \   000000A8   0x2A00             CMP      R2,#+0
   \   000000AA   0xD023             BEQ.N    ??LPLD_SDHC_Read_8
    820            {
    821              //剩下的少于单字长度数据
    822              if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   000000AC   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x400b1030
   \   000000B0   0x681B             LDR      R3,[R3, #+0]
   \   000000B2   0xF413 0x0FE0      TST      R3,#0x700000
   \   000000B6   0xD00B             BEQ.N    ??LPLD_SDHC_Read_9
    823              {
    824                SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   000000C2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    825                return SDHCRES_ERROR;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xE024             B.N      ??LPLD_SDHC_Read_5
    826              }
    827              
    828              //等待，直到收到的数据达到水印长度或传输完成
    829              while ((0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_9: (+1)
   \   000000D0   0x....             LDR.N    R3,??DataTable8_7  ;; 0x400b1024
   \   000000D2   0x681B             LDR      R3,[R3, #+0]
   \   000000D4   0x051B             LSLS     R3,R3,#+20
   \   000000D6   0xD403             BMI.N    ??LPLD_SDHC_Read_10
   \   000000D8   0x....             LDR.N    R3,??DataTable8_7  ;; 0x400b1024
   \   000000DA   0x681B             LDR      R3,[R3, #+0]
   \   000000DC   0x075B             LSLS     R3,R3,#+29
   \   000000DE   0xD4F7             BMI.N    ??LPLD_SDHC_Read_9
    830              { };
    831              
    832              buffer = SDHC->DATPORT;
   \                     ??LPLD_SDHC_Read_10: (+1)
   \   000000E0   0x.... 0x....      LDR.W    R3,??DataTable11_13  ;; 0x400b1020
   \   000000E4   0x681B             LDR      R3,[R3, #+0]
   \   000000E6   0xE003             B.N      ??LPLD_SDHC_Read_11
    833              while (remains)
    834              {
    835                
    836                *data_ptr++ = buffer & 0xFF;
   \                     ??LPLD_SDHC_Read_12: (+1)
   \   000000E8   0x7003             STRB     R3,[R0, #+0]
   \   000000EA   0x1C40             ADDS     R0,R0,#+1
    837                buffer >>= 8;
   \   000000EC   0x0A1B             LSRS     R3,R3,#+8
    838                
    839                remains--;
   \   000000EE   0x1E52             SUBS     R2,R2,#+1
    840              }
   \                     ??LPLD_SDHC_Read_11: (+1)
   \   000000F0   0x2A00             CMP      R2,#+0
   \   000000F2   0xD1F9             BNE.N    ??LPLD_SDHC_Read_12
    841            }
    842            
    843            if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \                     ??LPLD_SDHC_Read_8: (+1)
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000F8   0x6800             LDR      R0,[R0, #+0]
   \   000000FA   0xF410 0x0FE0      TST      R0,#0x700000
   \   000000FE   0xD00B             BEQ.N    ??LPLD_SDHC_Read_13
    844            {
    845              SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000010A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000112   0x6008             STR      R0,[R1, #+0]
    846              return SDHCRES_ERROR;
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0xE000             B.N      ??LPLD_SDHC_Read_5
    847            }
    848            
    849            return (n - remains);
   \                     ??LPLD_SDHC_Read_13: (+1)
   \   00000118   0x1A88             SUBS     R0,R1,R2
   \                     ??LPLD_SDHC_Read_5: (+1)
   \   0000011A   0xBC10             POP      {R4}
   \   0000011C   0x4770             BX       LR               ;; return
    850          }
    851          
    852          /*
    853           * LPLD_SDHC_Write
    854           * SDHC写操作
    855           * 
    856           * 参数:
    857           *    *data_ptr--存储数据地址指针
    858           *    n--待写的数据长度
    859           *
    860           * 输出:
    861           *    SDHCRES--磁盘功能返回值
    862           */

   \                                 In section .text, align 2, keep-with-next
    863          static SDHCSTATUS LPLD_SDHC_Write(uint8 *data_ptr, int32 n)
    864          {
   \                     LPLD_SDHC_Write: (+1)
   \   00000000   0xB410             PUSH     {R4}
    865            uint8 *udata_ptr;
    866            uint32 buffer;
    867            int32 remains;
    868            
    869            //复制数据指针
    870            udata_ptr = (uint8 *)data_ptr;
    871            
    872            remains = n;
   \   00000002   0x000A             MOVS     R2,R1
    873            if (((uint32)udata_ptr & 0x03) == 0)
   \   00000004   0xF010 0x0303      ANDS     R3,R0,#0x3
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD138             BNE.N    ??LPLD_SDHC_Write_0
   \   0000000C   0xE009             B.N      ??LPLD_SDHC_Write_1
    874            {
    875              //数据位字对齐，可以以最快的速度直接拷贝到寄存器
    876              while (remains >= 4)
    877              {
    878                if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
    879                {
    880                  SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
    881                  return SDHCRES_ERROR;
    882                }
    883                
    884                //等待，直到水印空间可用 
    885                while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_2: (+1)
   \   0000000E   0x....             LDR.N    R3,??DataTable8_7  ;; 0x400b1024
   \   00000010   0x681B             LDR      R3,[R3, #+0]
   \   00000012   0x055B             LSLS     R3,R3,#+21
   \   00000014   0xD5FB             BPL.N    ??LPLD_SDHC_Write_2
    886                { };
    887                
    888                SDHC->DATPORT = *((uint32 *)udata_ptr);
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable11_13  ;; 0x400b1020
   \   0000001C   0x6023             STR      R3,[R4, #+0]
    889                udata_ptr += 4;
   \   0000001E   0x1D00             ADDS     R0,R0,#+4
    890                remains -= 4;
   \   00000020   0x1F12             SUBS     R2,R2,#+4
   \                     ??LPLD_SDHC_Write_1: (+1)
   \   00000022   0x2A04             CMP      R2,#+4
   \   00000024   0xDB3C             BLT.N    ??LPLD_SDHC_Write_3
   \   00000026   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x400b1030
   \   0000002A   0x681B             LDR      R3,[R3, #+0]
   \   0000002C   0xF413 0x0FE0      TST      R3,#0x700000
   \   00000030   0xD0ED             BEQ.N    ??LPLD_SDHC_Write_2
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000003C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE05B             B.N      ??LPLD_SDHC_Write_4
    891              }
    892            }
    893            else
    894            {
    895              //非对齐数据，写到临时区域并以字节复制
    896              while (remains >= 4)
    897              {
    898                if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
    899                {
    900                  SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
    901                  return SDHCRES_ERROR;
    902                }
    903                
    904                //等待，直到水印空间可用 
    905                while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_5: (+1)
   \   0000004A   0x....             LDR.N    R3,??DataTable8_7  ;; 0x400b1024
   \   0000004C   0x681B             LDR      R3,[R3, #+0]
   \   0000004E   0x055B             LSLS     R3,R3,#+21
   \   00000050   0xD5FB             BPL.N    ??LPLD_SDHC_Write_5
    906                { };
    907                
    908                buffer  = (*udata_ptr++);
   \   00000052   0x7803             LDRB     R3,[R0, #+0]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
    909                buffer |= (*udata_ptr++) << 8;
   \   00000056   0x7804             LDRB     R4,[R0, #+0]
   \   00000058   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
    910                buffer |= (*udata_ptr++) << 16;
   \   0000005E   0x7804             LDRB     R4,[R0, #+0]
   \   00000060   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \   00000064   0x1C40             ADDS     R0,R0,#+1
    911                buffer |= (*udata_ptr++) << 24;
   \   00000066   0x7804             LDRB     R4,[R0, #+0]
   \   00000068   0xEA53 0x6304      ORRS     R3,R3,R4, LSL #+24
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
    912                
    913                //等待，直到水印空间可用 
    914                while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_6: (+1)
   \   0000006E   0x....             LDR.N    R4,??DataTable8_7  ;; 0x400b1024
   \   00000070   0x6824             LDR      R4,[R4, #+0]
   \   00000072   0x0564             LSLS     R4,R4,#+21
   \   00000074   0xD5FB             BPL.N    ??LPLD_SDHC_Write_6
    915                { };
    916                
    917                SDHC->DATPORT = buffer;
   \   00000076   0x.... 0x....      LDR.W    R4,??DataTable11_13  ;; 0x400b1020
   \   0000007A   0x6023             STR      R3,[R4, #+0]
    918                remains -= 4;
   \   0000007C   0x1F12             SUBS     R2,R2,#+4
   \                     ??LPLD_SDHC_Write_0: (+1)
   \   0000007E   0x2A04             CMP      R2,#+4
   \   00000080   0xDB0E             BLT.N    ??LPLD_SDHC_Write_3
   \   00000082   0x....             LDR.N    R3,??DataTable10  ;; 0x400b1030
   \   00000084   0x681B             LDR      R3,[R3, #+0]
   \   00000086   0xF413 0x0FE0      TST      R3,#0x700000
   \   0000008A   0xD0DE             BEQ.N    ??LPLD_SDHC_Write_5
   \   0000008C   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000094   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000098   0x....             LDR.N    R1,??DataTable10  ;; 0x400b1030
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE030             B.N      ??LPLD_SDHC_Write_4
    919              }      
    920            }
    921            
    922            if (remains)
   \                     ??LPLD_SDHC_Write_3: (+1)
   \   000000A0   0x2A00             CMP      R2,#+0
   \   000000A2   0xD01E             BEQ.N    ??LPLD_SDHC_Write_7
    923            {
    924              //剩余少于单字长度的数据
    925              if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   000000A4   0x....             LDR.N    R3,??DataTable10  ;; 0x400b1030
   \   000000A6   0x681B             LDR      R3,[R3, #+0]
   \   000000A8   0xF413 0x0FE0      TST      R3,#0x700000
   \   000000AC   0xD009             BEQ.N    ??LPLD_SDHC_Write_8
    926              {
    927                SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   000000AE   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   000000B6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000BA   0x....             LDR.N    R1,??DataTable10  ;; 0x400b1030
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    928                return SDHCRES_ERROR;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE01F             B.N      ??LPLD_SDHC_Write_4
    929              }
    930              
    931              buffer = 0xFFFFFFFF;
   \                     ??LPLD_SDHC_Write_8: (+1)
   \   000000C2   0xF05F 0x33FF      MOVS     R3,#-1
   \   000000C6   0xE003             B.N      ??LPLD_SDHC_Write_9
    932              while (remains)
    933              {
    934                buffer <<= 8;
   \                     ??LPLD_SDHC_Write_10: (+1)
   \   000000C8   0x021B             LSLS     R3,R3,#+8
    935                buffer |= udata_ptr[remains];
   \   000000CA   0x5C14             LDRB     R4,[R2, R0]
   \   000000CC   0x4323             ORRS     R3,R4,R3
    936                remains--;
   \   000000CE   0x1E52             SUBS     R2,R2,#+1
    937              }
   \                     ??LPLD_SDHC_Write_9: (+1)
   \   000000D0   0x2A00             CMP      R2,#+0
   \   000000D2   0xD1F9             BNE.N    ??LPLD_SDHC_Write_10
    938              
    939              //等待，直到水印空间可用 
    940              while (0 == (SDHC->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_11: (+1)
   \   000000D4   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400b1024
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x0540             LSLS     R0,R0,#+21
   \   000000DA   0xD5FB             BPL.N    ??LPLD_SDHC_Write_11
    941              { };
    942              
    943              SDHC->DATPORT = buffer;        
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable11_13  ;; 0x400b1020
   \   000000E0   0x6003             STR      R3,[R0, #+0]
    944            }
    945            
    946            if (SDHC->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \                     ??LPLD_SDHC_Write_7: (+1)
   \   000000E2   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF410 0x0FE0      TST      R0,#0x700000
   \   000000EA   0xD009             BEQ.N    ??LPLD_SDHC_Write_12
    947            {
    948              SDHC->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   000000EC   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   000000F4   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000F8   0x....             LDR.N    R1,??DataTable10  ;; 0x400b1030
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    949              return SDHCRES_ERROR;
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0xE000             B.N      ??LPLD_SDHC_Write_4
    950            }
    951            
    952            return (n - remains);
   \                     ??LPLD_SDHC_Write_12: (+1)
   \   00000100   0x1A88             SUBS     R0,R1,R2
   \                     ??LPLD_SDHC_Write_4: (+1)
   \   00000102   0xBC10             POP      {R4}
   \   00000104   0x4770             BX       LR               ;; return
    953          }
    954          
    955          /*
    956           * LPLD_SDHC_InitCard
    957           * 初始化SDHC模块及SD卡，设置正常工作波特率为40MHz
    958           * 
    959           * 参数:
    960           *    无
    961           *
    962           * 输出:
    963           *    SDHCSTA_OK--状态正常
    964           *    SDHCSTA_NOINIT--驱动未初始化
    965           *    SDHCSTA_NODISK--为插入卡
    966           *    SDHCSTA_PROTECT--卡写保护
    967           */

   \                                 In section .text, align 2, keep-with-next
    968          SDHCSTATUS LPLD_SDHC_InitCard(void)
    969          {
   \                     LPLD_SDHC_InitCard: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
    970            uint32 param, c_size, c_size_mult, read_bl_len, time_out = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    971            ESDHC_COMMAND_STRUCT command;
    972            SDHCSTATUS result;
    973            
    974            //分配SD卡信息结构体的数据空间并初始化
    975            sdcard_ptr = (SDCARD_STRUCT_PTR)malloc(sizeof(SDCARD_STRUCT));
   \   00000006   0x2018             MOVS     R0,#+24
   \   00000008   0x.... 0x....      BL       malloc
   \   0000000C   0x....             LDR.N    R1,??DataTable10_1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    976            sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable10_1
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x6108             STR      R0,[R1, #+16]
    977            sdcard_ptr->TIMEOUT = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable10_1
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    978            sdcard_ptr->NUM_BLOCKS = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable10_1
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0x6048             STR      R0,[R1, #+4]
    979            sdcard_ptr->ADDRESS = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable10_1
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x60C8             STR      R0,[R1, #+12]
    980            sdcard_ptr->HC = FALSE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x....             LDR.N    R1,??DataTable10_1
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x7208             STRB     R0,[R1, #+8]
    981            sdcard_ptr->VERSION2 = FALSE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x....             LDR.N    R1,??DataTable10_1
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0x7248             STRB     R0,[R1, #+9]
    982            sdcard_ptr->STATUS = SDHCSTA_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x....             LDR.N    R1,??DataTable10_1
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x6148             STR      R0,[R1, #+20]
   \   00000048   0xE7FF             B.N      ??LPLD_SDHC_InitCard_0
    983             
    984            while(time_out < 1000)
    985            {
    986              
    987              //初始化SDHC模块并检测卡
    988              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_INIT, NULL)))
    989              {
    990                continue;
   \                     ??LPLD_SDHC_InitCard_1: (+1)
   \                     ??LPLD_SDHC_InitCard_0: (+1)
   \   0000004A   0xF5B4 0x7F7A      CMP      R4,#+1000
   \   0000004E   0xD223             BCS.N    ??LPLD_SDHC_InitCard_2
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD1F6             BNE.N    ??LPLD_SDHC_InitCard_1
    991              }
    992              
    993              //SDHC检查
    994              param = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x9000             STR      R0,[SP, #+0]
    995              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_GET_CARD, &param)))
   \   00000060   0xA900             ADD      R1,SP,#+0
   \   00000062   0x2003             MOVS     R0,#+3
   \   00000064   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD1EE             BNE.N    ??LPLD_SDHC_InitCard_0
    996              {
    997                continue;
    998              }
    999              if ((ESDHC_CARD_SD == param) || (ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDCOMBO == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??LPLD_SDHC_InitCard_3: (+1)
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD008             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x2803             CMP      R0,#+3
   \   00000076   0xD005             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   00000078   0x9800             LDR      R0,[SP, #+0]
   \   0000007A   0x2805             CMP      R0,#+5
   \   0000007C   0xD002             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x2806             CMP      R0,#+6
   \   00000082   0xD113             BNE.N    ??LPLD_SDHC_InitCard_5
   1000              {
   1001                if ((ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??LPLD_SDHC_InitCard_4: (+1)
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x2803             CMP      R0,#+3
   \   00000088   0xD002             BEQ.N    ??LPLD_SDHC_InitCard_6
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x2806             CMP      R0,#+6
   \   0000008E   0xD108             BNE.N    ??LPLD_SDHC_InitCard_7
   1002                {
   1003                  sdcard_ptr->HC = TRUE;
   \                     ??LPLD_SDHC_InitCard_6: (+1)
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x....             LDR.N    R1,??DataTable10_1
   \   00000094   0x6809             LDR      R1,[R1, #+0]
   \   00000096   0x7208             STRB     R0,[R1, #+8]
   1004                  break;
   1005                }
   1006                else if(ESDHC_CARD_SD == param)
   1007                {
   1008                  break;
   1009                }
   1010              }
   1011              else
   1012              {
   1013                continue;
   1014              }
   1015              time_out++;
   1016            }
   1017            
   1018            if(time_out >= 1000)
   \                     ??LPLD_SDHC_InitCard_2: (+1)
   \   00000098   0xF5B4 0x7F7A      CMP      R4,#+1000
   \   0000009C   0xD307             BCC.N    ??LPLD_SDHC_InitCard_8
   1019              return SDHCRES_NOTRDY;
   \   0000009E   0x2003             MOVS     R0,#+3
   \   000000A0   0xE0A6             B.N      ??LPLD_SDHC_InitCard_9
   \                     ??LPLD_SDHC_InitCard_7: (+1)
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD0F7             BEQ.N    ??LPLD_SDHC_InitCard_2
   \                     ??LPLD_SDHC_InitCard_10: (+1)
   \   000000A8   0x1C64             ADDS     R4,R4,#+1
   \   000000AA   0xE7CE             B.N      ??LPLD_SDHC_InitCard_0
   \                     ??LPLD_SDHC_InitCard_5: (+1)
   \   000000AC   0xE7CD             B.N      ??LPLD_SDHC_InitCard_0
   1020            
   1021            //卡识别
   1022            command.COMMAND = ESDHC_CMD2;
   \                     ??LPLD_SDHC_InitCard_8: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable11_14  ;; 0x2090000
   \   000000B2   0x9001             STR      R0,[SP, #+4]
   1023            command.ARGUMENT = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x9002             STR      R0,[SP, #+8]
   1024            command.BLOCKS = 0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x9003             STR      R0,[SP, #+12]
   1025            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000BC   0xA901             ADD      R1,SP,#+4
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xF040 0x8093      BNE.W    ??LPLD_SDHC_InitCard_9
   1026            {
   1027              return result;
   1028            }
   1029            
   1030            //获取卡地址
   1031            command.COMMAND = ESDHC_CMD3;
   \                     ??LPLD_SDHC_InitCard_11: (+1)
   \   000000CA   0x....             LDR.N    R0,??DataTable11_15  ;; 0x31a0000
   \   000000CC   0x9001             STR      R0,[SP, #+4]
   1032            command.ARGUMENT = 0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9002             STR      R0,[SP, #+8]
   1033            command.BLOCKS = 0;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x9003             STR      R0,[SP, #+12]
   1034            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000D6   0xA901             ADD      R1,SP,#+4
   \   000000D8   0x2002             MOVS     R0,#+2
   \   000000DA   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xF040 0x8086      BNE.W    ??LPLD_SDHC_InitCard_9
   1035            {
   1036              return result;
   1037            }
   1038            sdcard_ptr->ADDRESS = command.RESPONSE[0] & 0xFFFF0000;
   \                     ??LPLD_SDHC_InitCard_12: (+1)
   \   000000E4   0x9805             LDR      R0,[SP, #+20]
   \   000000E6   0x0C00             LSRS     R0,R0,#+16
   \   000000E8   0x0400             LSLS     R0,R0,#+16
   \   000000EA   0x....             LDR.N    R1,??DataTable10_1
   \   000000EC   0x6809             LDR      R1,[R1, #+0]
   \   000000EE   0x60C8             STR      R0,[R1, #+12]
   1039            
   1040            //获取卡参数
   1041            command.COMMAND = ESDHC_CMD9;
   \   000000F0   0x....             LDR.N    R0,??DataTable11_16  ;; 0x9090000
   \   000000F2   0x9001             STR      R0,[SP, #+4]
   1042            command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000F4   0x....             LDR.N    R0,??DataTable10_1
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x68C0             LDR      R0,[R0, #+12]
   \   000000FA   0x9002             STR      R0,[SP, #+8]
   1043            command.BLOCKS = 0;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x9003             STR      R0,[SP, #+12]
   1044            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   00000100   0xA901             ADD      R1,SP,#+4
   \   00000102   0x2002             MOVS     R0,#+2
   \   00000104   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD171             BNE.N    ??LPLD_SDHC_InitCard_9
   1045            {
   1046              return result;
   1047            }
   1048            if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??LPLD_SDHC_InitCard_13: (+1)
   \   0000010C   0x9808             LDR      R0,[SP, #+32]
   \   0000010E   0xF410 0x0F40      TST      R0,#0xC00000
   \   00000112   0xD11B             BNE.N    ??LPLD_SDHC_InitCard_14
   1049            {
   1050              read_bl_len = (command.RESPONSE[2] >> 8) & 0x0F;
   \   00000114   0x9807             LDR      R0,[SP, #+28]
   \   00000116   0xF3C0 0x2203      UBFX     R2,R0,#+8,#+4
   1051              c_size = command.RESPONSE[2] & 0x03;
   \   0000011A   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   0000011E   0xF010 0x0003      ANDS     R0,R0,#0x3
   1052              c_size = (c_size << 10) | (command.RESPONSE[1] >> 22);
   \   00000122   0x9906             LDR      R1,[SP, #+24]
   \   00000124   0x0D89             LSRS     R1,R1,#+22
   \   00000126   0xEA51 0x2080      ORRS     R0,R1,R0, LSL #+10
   1053              c_size_mult = (command.RESPONSE[1] >> 7) & 0x07;
   \   0000012A   0x9906             LDR      R1,[SP, #+24]
   \   0000012C   0xF3C1 0x11C2      UBFX     R1,R1,#+7,#+3
   1054              sdcard_ptr->NUM_BLOCKS = (c_size + 1) * (1 << (c_size_mult + 2)) * (1 << (read_bl_len - 9));
   \   00000130   0x1C40             ADDS     R0,R0,#+1
   \   00000132   0x2301             MOVS     R3,#+1
   \   00000134   0x1C89             ADDS     R1,R1,#+2
   \   00000136   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000013A   0x4348             MULS     R0,R1,R0
   \   0000013C   0x2101             MOVS     R1,#+1
   \   0000013E   0x3A09             SUBS     R2,R2,#+9
   \   00000140   0x4091             LSLS     R1,R1,R2
   \   00000142   0x4348             MULS     R0,R1,R0
   \   00000144   0x....             LDR.N    R1,??DataTable10_1
   \   00000146   0x6809             LDR      R1,[R1, #+0]
   \   00000148   0x6048             STR      R0,[R1, #+4]
   \   0000014A   0xE00B             B.N      ??LPLD_SDHC_InitCard_15
   1055            }
   1056            else
   1057            {
   1058              sdcard_ptr->VERSION2 = TRUE;
   \                     ??LPLD_SDHC_InitCard_14: (+1)
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0x....             LDR.N    R1,??DataTable10_1
   \   00000150   0x6809             LDR      R1,[R1, #+0]
   \   00000152   0x7248             STRB     R0,[R1, #+9]
   1059              c_size = (command.RESPONSE[1] >> 8) & 0x003FFFFF;
   \   00000154   0x9806             LDR      R0,[SP, #+24]
   \   00000156   0xF3C0 0x2015      UBFX     R0,R0,#+8,#+22
   1060              sdcard_ptr->NUM_BLOCKS = (c_size + 1) << 10;
   \   0000015A   0x1C40             ADDS     R0,R0,#+1
   \   0000015C   0x0280             LSLS     R0,R0,#+10
   \   0000015E   0x....             LDR.N    R1,??DataTable10_1
   \   00000160   0x6809             LDR      R1,[R1, #+0]
   \   00000162   0x6048             STR      R0,[R1, #+4]
   1061            }
   1062            
   1063            //设置正常工作波特率为40MHz
   1064            //param = 40000000;    
   1065            param = 25000000;      
   \                     ??LPLD_SDHC_InitCard_15: (+1)
   \   00000164   0x....             LDR.N    R0,??DataTable11_12  ;; 0x17d7840
   \   00000166   0x9000             STR      R0,[SP, #+0]
   1066            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SET_BAUDRATE, &param)))
   \   00000168   0xA900             ADD      R1,SP,#+0
   \   0000016A   0x2005             MOVS     R0,#+5
   \   0000016C   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD13D             BNE.N    ??LPLD_SDHC_InitCard_9
   1067            {
   1068              return result;
   1069            }
   1070            
   1071            //选择卡
   1072            command.COMMAND = ESDHC_CMD7;
   \                     ??LPLD_SDHC_InitCard_16: (+1)
   \   00000174   0x....             LDR.N    R0,??DataTable11_17  ;; 0x71b0000
   \   00000176   0x9001             STR      R0,[SP, #+4]
   1073            command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000178   0x....             LDR.N    R0,??DataTable10_1
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x68C0             LDR      R0,[R0, #+12]
   \   0000017E   0x9002             STR      R0,[SP, #+8]
   1074            command.BLOCKS = 0;
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x9003             STR      R0,[SP, #+12]
   1075            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   00000184   0xA901             ADD      R1,SP,#+4
   \   00000186   0x2002             MOVS     R0,#+2
   \   00000188   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD12F             BNE.N    ??LPLD_SDHC_InitCard_9
   1076            {
   1077              return result;
   1078            }
   1079            
   1080            //设置块大小为512字节
   1081            command.COMMAND = ESDHC_CMD16;
   \                     ??LPLD_SDHC_InitCard_17: (+1)
   \   00000190   0x....             LDR.N    R0,??DataTable11_18  ;; 0x101a0000
   \   00000192   0x9001             STR      R0,[SP, #+4]
   1082            command.ARGUMENT = IO_SDCARD_BLOCK_SIZE;
   \   00000194   0xF44F 0x7000      MOV      R0,#+512
   \   00000198   0x9002             STR      R0,[SP, #+8]
   1083            command.BLOCKS = 0;
   \   0000019A   0x2000             MOVS     R0,#+0
   \   0000019C   0x9003             STR      R0,[SP, #+12]
   1084            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000019E   0xA901             ADD      R1,SP,#+4
   \   000001A0   0x2002             MOVS     R0,#+2
   \   000001A2   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD122             BNE.N    ??LPLD_SDHC_InitCard_9
   1085            {
   1086              return result;
   1087            }
   1088            
   1089            if (ESDHC_BUS_WIDTH_4BIT == ESDHC_BUS_WIDTH_4BIT)
   1090            {
   1091              //特殊应用命令
   1092              command.COMMAND = ESDHC_CMD55;
   \                     ??LPLD_SDHC_InitCard_18: (+1)
   \   000001AA   0x....             LDR.N    R0,??DataTable11_8  ;; 0x371a0000
   \   000001AC   0x9001             STR      R0,[SP, #+4]
   1093              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000001AE   0x....             LDR.N    R0,??DataTable10_1
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0x68C0             LDR      R0,[R0, #+12]
   \   000001B4   0x9002             STR      R0,[SP, #+8]
   1094              command.BLOCKS = 0;
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0x9003             STR      R0,[SP, #+12]
   1095              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000001BA   0xA901             ADD      R1,SP,#+4
   \   000001BC   0x2002             MOVS     R0,#+2
   \   000001BE   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001C2   0x2800             CMP      R0,#+0
   \   000001C4   0xD114             BNE.N    ??LPLD_SDHC_InitCard_9
   1096              {
   1097                return result;
   1098              }
   1099              
   1100              //设置总线宽度为4bit
   1101              command.COMMAND = ESDHC_ACMD6;
   \                     ??LPLD_SDHC_InitCard_19: (+1)
   \   000001C6   0x....             LDR.N    R0,??DataTable11_19  ;; 0x61a0000
   \   000001C8   0x9001             STR      R0,[SP, #+4]
   1102              command.ARGUMENT = 2;
   \   000001CA   0x2002             MOVS     R0,#+2
   \   000001CC   0x9002             STR      R0,[SP, #+8]
   1103              command.BLOCKS = 0;
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0x9003             STR      R0,[SP, #+12]
   1104              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000001D2   0xA901             ADD      R1,SP,#+4
   \   000001D4   0x2002             MOVS     R0,#+2
   \   000001D6   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001DA   0x2800             CMP      R0,#+0
   \   000001DC   0xD108             BNE.N    ??LPLD_SDHC_InitCard_9
   1105              {
   1106                return result;
   1107              }
   1108              
   1109              param = ESDHC_BUS_WIDTH_4BIT;
   \                     ??LPLD_SDHC_InitCard_20: (+1)
   \   000001DE   0x2001             MOVS     R0,#+1
   \   000001E0   0x9000             STR      R0,[SP, #+0]
   1110              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SET_BUS_WIDTH, &param)))
   \   000001E2   0xA900             ADD      R1,SP,#+0
   \   000001E4   0x2007             MOVS     R0,#+7
   \   000001E6   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xD100             BNE.N    ??LPLD_SDHC_InitCard_9
   1111              {
   1112                return result;
   1113              }
   1114            }
   1115            
   1116            return SDHCRES_OK;
   \                     ??LPLD_SDHC_InitCard_21: (+1)
   \   000001EE   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_InitCard_9: (+1)
   \   000001F0   0xB00A             ADD      SP,SP,#+40
   \   000001F2   0xBD10             POP      {R4,PC}          ;; return
   1117          }
   1118          
   1119          
   1120          /*
   1121           * LPLD_SDHC_ReadBlocks
   1122           * 读指定扇区指定长度的块
   1123           * 
   1124           * 参数:
   1125           *    buff--存储读出数据的地址指针
   1126           *    sector--开始的扇区号
   1127           *    count--读出的扇区数（块数）
   1128           *
   1129           * 输出:
   1130           *    SDHCRES--磁盘功能返回值
   1131           */

   \                                 In section .text, align 2, keep-with-next
   1132          SDHCRES LPLD_SDHC_ReadBlocks(uint8 *buff, uint32 sector, uint32 count)
   1133          {
   \                     LPLD_SDHC_ReadBlocks: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   1134            ESDHC_COMMAND_STRUCT command;
   1135            int cnt;
   1136            int32 result;
   1137            
   1138            //SD卡数据地址调节
   1139            if (! sdcard_ptr->HC)
   \   00000008   0x....             LDR.N    R0,??DataTable10_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD100             BNE.N    ??LPLD_SDHC_ReadBlocks_0
   1140            {
   1141              sector <<= IO_SDCARD_BLOCK_SIZE_POWER;
   \   00000012   0x0249             LSLS     R1,R1,#+9
   1142            }
   1143            
   1144            //设置读块命令
   1145            if (count > 1)
   \                     ??LPLD_SDHC_ReadBlocks_0: (+1)
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD302             BCC.N    ??LPLD_SDHC_ReadBlocks_1
   1146            {
   1147              command.COMMAND = ESDHC_CMD18;
   \   00000018   0x....             LDR.N    R0,??DataTable11_20  ;; 0x121a0034
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0xE001             B.N      ??LPLD_SDHC_ReadBlocks_2
   1148            }   
   1149            else
   1150            {
   1151              command.COMMAND = ESDHC_CMD17;
   \                     ??LPLD_SDHC_ReadBlocks_1: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable11_21  ;; 0x111a0010
   \   00000020   0x9000             STR      R0,[SP, #+0]
   1152            }
   1153            
   1154            command.ARGUMENT = sector;
   \                     ??LPLD_SDHC_ReadBlocks_2: (+1)
   \   00000022   0x9101             STR      R1,[SP, #+4]
   1155            command.BLOCKS = count;
   \   00000024   0x9502             STR      R5,[SP, #+8]
   1156            command.BLOCKSIZE = IO_SDCARD_BLOCK_SIZE;
   \   00000026   0xF44F 0x7000      MOV      R0,#+512
   \   0000002A   0x9003             STR      R0,[SP, #+12]
   1157            if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ.N    ??LPLD_SDHC_ReadBlocks_3
   1158            {
   1159              return (SDHCRES)result;
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE019             B.N      ??LPLD_SDHC_ReadBlocks_4
   1160            }
   1161            
   1162            //读取数据
   1163            for (cnt = 0; cnt < count; cnt++)
   \                     ??LPLD_SDHC_ReadBlocks_3: (+1)
   \   0000003C   0x2600             MOVS     R6,#+0
   \   0000003E   0xE002             B.N      ??LPLD_SDHC_ReadBlocks_5
   1164            {
   1165              if (IO_SDCARD_BLOCK_SIZE != (result=LPLD_SDHC_Read(buff,IO_SDCARD_BLOCK_SIZE)))
   1166              {
   1167                return (SDHCRES)result;
   1168              }
   1169              buff += IO_SDCARD_BLOCK_SIZE;
   \                     ??LPLD_SDHC_ReadBlocks_6: (+1)
   \   00000040   0xF514 0x7400      ADDS     R4,R4,#+512
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   \                     ??LPLD_SDHC_ReadBlocks_5: (+1)
   \   00000046   0x42AE             CMP      R6,R5
   \   00000048   0xD209             BCS.N    ??LPLD_SDHC_ReadBlocks_7
   \   0000004A   0xF44F 0x7100      MOV      R1,#+512
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       LPLD_SDHC_Read
   \   00000054   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000058   0xD0F2             BEQ.N    ??LPLD_SDHC_ReadBlocks_6
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0xE008             B.N      ??LPLD_SDHC_ReadBlocks_4
   1170            }
   1171            
   1172            //等待传输结束
   1173            if (SDHCRES_OK !=(result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_ReadBlocks_7: (+1)
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x2093             MOVS     R0,#+147
   \   00000062   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ.N    ??LPLD_SDHC_ReadBlocks_8
   1174            {
   1175              return (SDHCRES)result;
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0xE000             B.N      ??LPLD_SDHC_ReadBlocks_4
   1176            }
   1177            
   1178            return (SDHCRES)result;
   \                     ??LPLD_SDHC_ReadBlocks_8: (+1)
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??LPLD_SDHC_ReadBlocks_4: (+1)
   \   00000070   0xB008             ADD      SP,SP,#+32
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
   1179          }
   1180          
   1181          
   1182          /*
   1183           * LPLD_SDHC_WriteBlocks
   1184           * 在指定扇区写入指定长度块数数据
   1185           * 
   1186           * 参数:
   1187           *    buff--存储待写入数据的地址指针
   1188           *    sector--开始的扇区号
   1189           *    count--写入的扇区数（块数）
   1190           *
   1191           * 输出:
   1192           *    SDHCRES--磁盘功能返回值
   1193           */

   \                                 In section .text, align 2, keep-with-next
   1194          SDHCRES LPLD_SDHC_WriteBlocks(uint8* buff, uint32 sector, uint32 count)
   1195          {
   \                     LPLD_SDHC_WriteBlocks: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x0015             MOVS     R5,R2
   1196              ESDHC_COMMAND_STRUCT command;
   1197              uint8               tmp[4];
   1198              int32             cnt;
   1199                int32 result;
   1200              
   1201           
   1202              //SD卡数据地址调节
   1203              if (! sdcard_ptr->HC)
   \   00000008   0x....             LDR.N    R0,??DataTable11_22
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD100             BNE.N    ??LPLD_SDHC_WriteBlocks_0
   1204              {
   1205                  sector <<= IO_SDCARD_BLOCK_SIZE_POWER;
   \   00000012   0x0249             LSLS     R1,R1,#+9
   1206              }
   1207          
   1208              //设置写块命令
   1209              if (count > 1)
   \                     ??LPLD_SDHC_WriteBlocks_0: (+1)
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD302             BCC.N    ??LPLD_SDHC_WriteBlocks_1
   1210              {
   1211                  command.COMMAND = ESDHC_CMD25;
   \   00000018   0x....             LDR.N    R0,??DataTable11_23  ;; 0x191a0024
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0xE001             B.N      ??LPLD_SDHC_WriteBlocks_2
   1212              }
   1213              else
   1214              {
   1215                  command.COMMAND = ESDHC_CMD24;
   \                     ??LPLD_SDHC_WriteBlocks_1: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable11_24  ;; 0x181a0000
   \   00000020   0x9001             STR      R0,[SP, #+4]
   1216              }
   1217          
   1218              command.ARGUMENT = sector;
   \                     ??LPLD_SDHC_WriteBlocks_2: (+1)
   \   00000022   0x9102             STR      R1,[SP, #+8]
   1219              command.BLOCKS = count;
   \   00000024   0x9503             STR      R5,[SP, #+12]
   1220              command.BLOCKSIZE = IO_SDCARD_BLOCK_SIZE;
   \   00000026   0xF44F 0x7000      MOV      R0,#+512
   \   0000002A   0x9004             STR      R0,[SP, #+16]
   1221              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_3
   1222              {
   1223                  return (SDHCRES)result;
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE07C             B.N      ??LPLD_SDHC_WriteBlocks_4
   1224              }
   1225              
   1226              //写数据
   1227              for (cnt = 0; cnt < count; cnt++)
   \                     ??LPLD_SDHC_WriteBlocks_3: (+1)
   \   0000003C   0x2400             MOVS     R4,#+0
   \   0000003E   0xE002             B.N      ??LPLD_SDHC_WriteBlocks_5
   1228              {
   1229                  if (IO_SDCARD_BLOCK_SIZE != (result=LPLD_SDHC_Write (buff, IO_SDCARD_BLOCK_SIZE)))
   1230                  {
   1231                      return (SDHCRES)result;
   1232                  }
   1233                  buff += IO_SDCARD_BLOCK_SIZE;
   \                     ??LPLD_SDHC_WriteBlocks_6: (+1)
   \   00000040   0xF516 0x7600      ADDS     R6,R6,#+512
   \   00000044   0x1C64             ADDS     R4,R4,#+1
   \                     ??LPLD_SDHC_WriteBlocks_5: (+1)
   \   00000046   0x42AC             CMP      R4,R5
   \   00000048   0xD209             BCS.N    ??LPLD_SDHC_WriteBlocks_7
   \   0000004A   0xF44F 0x7100      MOV      R1,#+512
   \   0000004E   0x0030             MOVS     R0,R6
   \   00000050   0x.... 0x....      BL       LPLD_SDHC_Write
   \   00000054   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000058   0xD0F2             BEQ.N    ??LPLD_SDHC_WriteBlocks_6
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0xE06B             B.N      ??LPLD_SDHC_WriteBlocks_4
   1234              }
   1235          
   1236              //等待传输结束
   1237              if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_WriteBlocks_7: (+1)
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x2093             MOVS     R0,#+147
   \   00000062   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_8
   1238              {
   1239                  return (SDHCRES)result;
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0xE063             B.N      ??LPLD_SDHC_WriteBlocks_4
   1240              }
   1241          
   1242              //等待卡准备好/传输状态
   1243              do
   1244              {
   1245                  command.COMMAND = ESDHC_CMD13;
   \                     ??LPLD_SDHC_WriteBlocks_8: (+1)
   \   0000006E   0x....             LDR.N    R0,??DataTable11_25  ;; 0xd1a0000
   \   00000070   0x9001             STR      R0,[SP, #+4]
   1246                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000072   0x....             LDR.N    R0,??DataTable11_22
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x68C0             LDR      R0,[R0, #+12]
   \   00000078   0x9002             STR      R0,[SP, #+8]
   1247                  command.BLOCKS = 0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x9003             STR      R0,[SP, #+12]
   1248                  if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000007E   0xA901             ADD      R1,SP,#+4
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_9
   1249                  {
   1250                      return (SDHCRES)result;
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0xE053             B.N      ??LPLD_SDHC_WriteBlocks_4
   1251                  }
   1252          
   1253                  //卡状态错误检查
   1254                  if (command.RESPONSE[0] & 0xFFD98008)
   \                     ??LPLD_SDHC_WriteBlocks_9: (+1)
   \   0000008E   0x9805             LDR      R0,[SP, #+20]
   \   00000090   0x....             LDR.N    R1,??DataTable11_26  ;; 0xffd98008
   \   00000092   0x4208             TST      R0,R1
   \   00000094   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_10
   1255                  {
   1256                      count = 0; /* necessary to get real number of written blocks */
   \   00000096   0x2500             MOVS     R5,#+0
   1257                      break;
   \   00000098   0xE005             B.N      ??LPLD_SDHC_WriteBlocks_11
   1258                  }
   1259          
   1260              } while (0x000000900 != (command.RESPONSE[0] & 0x00001F00));
   \                     ??LPLD_SDHC_WriteBlocks_10: (+1)
   \   0000009A   0x9805             LDR      R0,[SP, #+20]
   \   0000009C   0xF410 0x50F8      ANDS     R0,R0,#0x1F00
   \   000000A0   0xF5B0 0x6F10      CMP      R0,#+2304
   \   000000A4   0xD1E3             BNE.N    ??LPLD_SDHC_WriteBlocks_8
   1261          
   1262              if (cnt != count)
   \                     ??LPLD_SDHC_WriteBlocks_11: (+1)
   \   000000A6   0x42AC             CMP      R4,R5
   \   000000A8   0xD044             BEQ.N    ??LPLD_SDHC_WriteBlocks_12
   1263              {
   1264                  //特殊应用命令
   1265                  command.COMMAND = ESDHC_CMD55;
   \   000000AA   0x....             LDR.N    R0,??DataTable11_8  ;; 0x371a0000
   \   000000AC   0x9001             STR      R0,[SP, #+4]
   1266                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000AE   0x....             LDR.N    R0,??DataTable11_22
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x68C0             LDR      R0,[R0, #+12]
   \   000000B4   0x9002             STR      R0,[SP, #+8]
   1267                  command.BLOCKS = 0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x9003             STR      R0,[SP, #+12]
   1268                  if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000BA   0xA901             ADD      R1,SP,#+4
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_13
   1269                  {
   1270                      return (SDHCRES)result;
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0xE035             B.N      ??LPLD_SDHC_WriteBlocks_4
   1271                  }
   1272                          
   1273                  //使用ACMD22命令获得写入的块数量
   1274                  command.COMMAND = ESDHC_ACMD22;
   \                     ??LPLD_SDHC_WriteBlocks_13: (+1)
   \   000000CA   0x....             LDR.N    R0,??DataTable11_27  ;; 0x161a0010
   \   000000CC   0x9001             STR      R0,[SP, #+4]
   1275                  command.ARGUMENT = 0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9002             STR      R0,[SP, #+8]
   1276                  command.BLOCKS = 1;
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0x9003             STR      R0,[SP, #+12]
   1277                  command.BLOCKSIZE = 4;
   \   000000D6   0x2004             MOVS     R0,#+4
   \   000000D8   0x9004             STR      R0,[SP, #+16]
   1278                  if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000DA   0xA901             ADD      R1,SP,#+4
   \   000000DC   0x2002             MOVS     R0,#+2
   \   000000DE   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_14
   1279                  {
   1280                      return (SDHCRES)result;
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E8   0xE025             B.N      ??LPLD_SDHC_WriteBlocks_4
   1281                  }
   1282                  
   1283                  if (4 != (result=LPLD_SDHC_Read (tmp, 4)))
   \                     ??LPLD_SDHC_WriteBlocks_14: (+1)
   \   000000EA   0x2104             MOVS     R1,#+4
   \   000000EC   0xA800             ADD      R0,SP,#+0
   \   000000EE   0x.... 0x....      BL       LPLD_SDHC_Read
   \   000000F2   0x2804             CMP      R0,#+4
   \   000000F4   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_15
   1284                  {
   1285                      return (SDHCRES)result;
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0xE01D             B.N      ??LPLD_SDHC_WriteBlocks_4
   1286                      
   1287                  }
   1288          
   1289                  if (SDHCRES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_WriteBlocks_15: (+1)
   \   000000FA   0x2100             MOVS     R1,#+0
   \   000000FC   0x2093             MOVS     R0,#+147
   \   000000FE   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_16
   1290                  {
   1291                      return (SDHCRES)result;
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0xE015             B.N      ??LPLD_SDHC_WriteBlocks_4
   1292                  }
   1293          
   1294                  count = (tmp[0] << 24) | (tmp[1] << 16) | (tmp[2] << 8) | tmp[3];
   \                     ??LPLD_SDHC_WriteBlocks_16: (+1)
   \   0000010A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000010E   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000112   0x0409             LSLS     R1,R1,#+16
   \   00000114   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000118   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   0000011C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000120   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000124   0xEA51 0x0500      ORRS     R5,R1,R0
   1295                  if ((cnt < 0) || (cnt > count))
   \   00000128   0x2C00             CMP      R4,#+0
   \   0000012A   0xD401             BMI.N    ??LPLD_SDHC_WriteBlocks_17
   \   0000012C   0x42A5             CMP      R5,R4
   \   0000012E   0xD201             BCS.N    ??LPLD_SDHC_WriteBlocks_12
   1296                      return SDHCRES_ERROR;
   \                     ??LPLD_SDHC_WriteBlocks_17: (+1)
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0xE000             B.N      ??LPLD_SDHC_WriteBlocks_4
   1297              }
   1298              
   1299              return SDHCRES_OK;
   \                     ??LPLD_SDHC_WriteBlocks_12: (+1)
   \   00000134   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_WriteBlocks_4: (+1)
   \   00000136   0xB00A             ADD      SP,SP,#+40
   \   00000138   0xBD70             POP      {R4-R6,PC}       ;; return
   1300          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x4004D008         DC32     0x4004d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x4004D00C         DC32     0x4004d00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x4004D014         DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x400B102C         DC32     0x400b102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x01008000         DC32     0x1008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400B10C0         DC32     0x400b10c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x400B1004         DC32     0x400b1004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x400B1044         DC32     0x400b1044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x400B1030         DC32     0x400b1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     sdcard_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x400B1028         DC32     0x400b1028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x007F00B3         DC32     0x7f00b3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400B1034         DC32     0x400b1034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x400B1008         DC32     0x400b1008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x400B1000         DC32     0x400b1000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x400B100C         DC32     0x400b100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x000E0001         DC32     0xe0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x400B1010         DC32     0x400b1010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x400B1014         DC32     0x400b1014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x400B1018         DC32     0x400b1018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x400B101C         DC32     0x400b101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x00061A80         DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     g_core_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x081A0000         DC32     0x81a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x05020000         DC32     0x5020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x371A0000         DC32     0x371a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x40300000         DC32     0x40300000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x27020000         DC32     0x27020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x29020000         DC32     0x29020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x400B1020         DC32     0x400b1020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x02090000         DC32     0x2090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x031A0000         DC32     0x31a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x09090000         DC32     0x9090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0x071B0000         DC32     0x71b0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   0x101A0000         DC32     0x101a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   0x061A0000         DC32     0x61a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   0x121A0034         DC32     0x121a0034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \   00000000   0x111A0010         DC32     0x111a0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \   00000000   0x........         DC32     sdcard_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \   00000000   0x191A0024         DC32     0x191a0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \   00000000   0x181A0000         DC32     0x181a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \   00000000   0x0D1A0000         DC32     0xd1a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \   00000000   0xFFD98008         DC32     0xffd98008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \   00000000   0x161A0010         DC32     0x161a0010

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      72   LPLD_SDHC_IOC
        72   -> LPLD_SDHC_Init
        72   -> LPLD_SDHC_InitGPIO
        72   -> LPLD_SDHC_IsRunning
        72   -> LPLD_SDHC_SendCommand
        72   -> LPLD_SDHC_SetBaudrate
        72   -> LPLD_SDHC_WaitStatus
      16   LPLD_SDHC_Init
        16   -> LPLD_SDHC_InitGPIO
        16   -> LPLD_SDHC_SetBaudrate
      48   LPLD_SDHC_InitCard
        48   -> LPLD_SDHC_IOC
        48   -> malloc
       0   LPLD_SDHC_InitGPIO
       0   LPLD_SDHC_IsRunning
       4   LPLD_SDHC_Read
      48   LPLD_SDHC_ReadBlocks
        48   -> LPLD_SDHC_IOC
        48   -> LPLD_SDHC_Read
      16   LPLD_SDHC_SendCommand
        16   -> LPLD_SDHC_WaitStatus
      16   LPLD_SDHC_SetBaudrate
       0   LPLD_SDHC_WaitStatus
       4   LPLD_SDHC_Write
      56   LPLD_SDHC_WriteBlocks
        56   -> LPLD_SDHC_IOC
        56   -> LPLD_SDHC_Read
        56   -> LPLD_SDHC_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
    1472  LPLD_SDHC_IOC
     204  LPLD_SDHC_Init
     500  LPLD_SDHC_InitCard
      88  LPLD_SDHC_InitGPIO
      24  LPLD_SDHC_IsRunning
     286  LPLD_SDHC_Read
     116  LPLD_SDHC_ReadBlocks
     316  LPLD_SDHC_SendCommand
     156  LPLD_SDHC_SetBaudrate
      16  LPLD_SDHC_WaitStatus
     262  LPLD_SDHC_Write
     314  LPLD_SDHC_WriteBlocks
       4  sdcard_ptr

 
     4 bytes in section .bss
 3 958 bytes in section .text
 
 3 958 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
