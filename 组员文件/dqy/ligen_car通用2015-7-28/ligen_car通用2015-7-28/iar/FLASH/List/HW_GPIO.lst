###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        25/Jul/2015  16:58:10
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\lib\LPLD\HW\HW_GPIO.c
#    Command line =  
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\lib\LPLD\HW\HW_GPIO.c
#        -D LPLD_K60 -D USE_K60F12 -lCN
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\List\
#        -lB
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\List\
#        -o
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4F -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\app\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\common\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\..\..\..\lib\USB\class\
#        -Ol -I "C:\Program Files\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\List\HW_GPIO.lst
#    Object file  =  
#        C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\project\ligen_car通用7-23-20.36\iar\FLASH\Obj\HW_GPIO.o
#
###############################################################################

C:\Users\Administrator\Desktop\lpld\LPLD_OSKinetis_V3.1\lib\LPLD\HW\HW_GPIO.c
      1          /**
      2           * @file HW_GPIO.c
      3           * @version 3.03[By LPLD]
      4           * @date 2014-2-10
      5           * @brief GPIO底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable9  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable9_1  ;; 0xe000e180
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     23          #include "HW_GPIO.h"
     24          
     25          
     26          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     27          GPIO_ISR_CALLBACK GPIO_ISR[5];
   \                     GPIO_ISR:
   \   00000000                      DS8 20
     28          
     29          /*
     30           * LPLD_GPIO_Init
     31           * GPIO通用初始化函数
     32           * 
     33           * 参数:
     34           *    gpio_init_structure--GPIO初始化结构体，
     35           *                        具体定义见GPIO_InitTypeDef
     36           *
     37           * 输出:
     38           *    0--配置错误
     39           *    1--配置成功
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          uint8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
     42          {
   \                     LPLD_GPIO_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB4F0             PUSH     {R4-R7}
     43            uint8 i;
     44            PORT_Type *portx;
     45            uint32 pcr = PORT_PCR_MUX(1)| gpio_init_structure.GPIO_PinControl; 
   \   00000004   0x9806             LDR      R0,[SP, #+24]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
     46            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   0000000A   0x9B04             LDR      R3,[SP, #+16]
     47            uint32 pins = gpio_init_structure.GPIO_Pins;
   \   0000000C   0x9905             LDR      R1,[SP, #+20]
     48            uint8 dir = gpio_init_structure.GPIO_Dir;
   \   0000000E   0xF89D 0x701C      LDRB     R7,[SP, #+28]
     49            uint8 output = gpio_init_structure.GPIO_Output;
   \   00000012   0xF89D 0x401D      LDRB     R4,[SP, #+29]
     50            GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
   \   00000016   0x9A08             LDR      R2,[SP, #+32]
     51            
     52            //参数检查
     53            ASSERT( ptx <= PTE);                  //判断端口
     54            ASSERT( dir <= 1 );                   //判断方向
     55            ASSERT( output <= 1 );                //判断输出电平状态
     56            
     57            if(ptx == PTA)
   \   00000018   0x....             LDR.N    R5,??DataTable9_2  ;; 0x400ff000
   \   0000001A   0x42AB             CMP      R3,R5
   \   0000001C   0xD10C             BNE.N    ??LPLD_GPIO_Init_0
     58            {
     59              portx = PORTA;  
   \   0000001E   0x....             LDR.N    R6,??DataTable9_3  ;; 0x40049000
     60              i = 0;
   \   00000020   0x2500             MOVS     R5,#+0
     61            }
     62            else if(ptx == PTB) 
     63            {
     64              portx = PORTB;
     65              i = 1;
     66            }
     67            else if(ptx == PTC) 
     68            {
     69              portx = PORTC;
     70              i = 2;
     71            }
     72            else if(ptx == PTD) 
     73            {
     74              portx = PORTD;
     75              i = 3; 
     76            }
     77            else if(ptx == PTE) 
     78            {
     79              portx = PORTE;
     80              i = 4;
     81            }
     82            else
     83              return 0;
     84            
     85            //输入或输出设置
     86            if(dir==DIR_OUTPUT)
   \                     ??LPLD_GPIO_Init_1: (+1)
   \   00000022   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000024   0x2F01             CMP      R7,#+1
   \   00000026   0xD123             BNE.N    ??LPLD_GPIO_Init_2
     87            {
     88              ptx->PDDR |= pins;
   \   00000028   0x695F             LDR      R7,[R3, #+20]
   \   0000002A   0x430F             ORRS     R7,R1,R7
   \   0000002C   0x615F             STR      R7,[R3, #+20]
     89              //设置初始输出
     90              if(output==OUTPUT_H)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C01             CMP      R4,#+1
   \   00000032   0xD11B             BNE.N    ??LPLD_GPIO_Init_3
     91              {
     92                ptx->PSOR = pins; 
   \   00000034   0x6059             STR      R1,[R3, #+4]
   \   00000036   0xE01E             B.N      ??LPLD_GPIO_Init_4
     93              }
   \                     ??LPLD_GPIO_Init_0: (+1)
   \   00000038   0x....             LDR.N    R5,??DataTable9_4  ;; 0x400ff040
   \   0000003A   0x42AB             CMP      R3,R5
   \   0000003C   0xD102             BNE.N    ??LPLD_GPIO_Init_5
   \   0000003E   0x....             LDR.N    R6,??DataTable9_5  ;; 0x4004a000
   \   00000040   0x2501             MOVS     R5,#+1
   \   00000042   0xE7EE             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_5: (+1)
   \   00000044   0x....             LDR.N    R5,??DataTable9_6  ;; 0x400ff080
   \   00000046   0x42AB             CMP      R3,R5
   \   00000048   0xD102             BNE.N    ??LPLD_GPIO_Init_6
   \   0000004A   0x....             LDR.N    R6,??DataTable9_7  ;; 0x4004b000
   \   0000004C   0x2502             MOVS     R5,#+2
   \   0000004E   0xE7E8             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_6: (+1)
   \   00000050   0x....             LDR.N    R5,??DataTable9_8  ;; 0x400ff0c0
   \   00000052   0x42AB             CMP      R3,R5
   \   00000054   0xD102             BNE.N    ??LPLD_GPIO_Init_7
   \   00000056   0x....             LDR.N    R6,??DataTable9_9  ;; 0x4004c000
   \   00000058   0x2503             MOVS     R5,#+3
   \   0000005A   0xE7E2             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_7: (+1)
   \   0000005C   0x....             LDR.N    R5,??DataTable9_10  ;; 0x400ff100
   \   0000005E   0x42AB             CMP      R3,R5
   \   00000060   0xD102             BNE.N    ??LPLD_GPIO_Init_8
   \   00000062   0x....             LDR.N    R6,??DataTable9_11  ;; 0x4004d000
   \   00000064   0x2504             MOVS     R5,#+4
   \   00000066   0xE7DC             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_8: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE019             B.N      ??LPLD_GPIO_Init_9
     94              else
     95              {
     96                ptx->PCOR = pins;
   \                     ??LPLD_GPIO_Init_3: (+1)
   \   0000006C   0x6099             STR      R1,[R3, #+8]
   \   0000006E   0xE002             B.N      ??LPLD_GPIO_Init_4
     97              }
     98            }
     99            else
    100            { 
    101              ptx->PDDR &= ~(pins);
   \                     ??LPLD_GPIO_Init_2: (+1)
   \   00000070   0x695C             LDR      R4,[R3, #+20]
   \   00000072   0x438C             BICS     R4,R4,R1
   \   00000074   0x615C             STR      R4,[R3, #+20]
    102            }
    103            
    104            //配置所选引脚的控制寄存器
    105            for(uint8 i=0; i<32; i++)
   \                     ??LPLD_GPIO_Init_4: (+1)
   \   00000076   0x2300             MOVS     R3,#+0
   \   00000078   0xE007             B.N      ??LPLD_GPIO_Init_10
    106            {
    107              if(pins&(1ul<<i))
   \                     ??LPLD_GPIO_Init_11: (+1)
   \   0000007A   0xFA31 0xF403      LSRS     R4,R1,R3
   \   0000007E   0x07E4             LSLS     R4,R4,#+31
   \   00000080   0xD502             BPL.N    ??LPLD_GPIO_Init_12
    108              {
    109                portx->PCR[i] = pcr;
   \   00000082   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000084   0xF846 0x0023      STR      R0,[R6, R3, LSL #+2]
    110              }
    111            }
   \                     ??LPLD_GPIO_Init_12: (+1)
   \   00000088   0x1C5B             ADDS     R3,R3,#+1
   \                     ??LPLD_GPIO_Init_10: (+1)
   \   0000008A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000008C   0x2B20             CMP      R3,#+32
   \   0000008E   0xDBF4             BLT.N    ??LPLD_GPIO_Init_11
    112          
    113            if(isr_func!=NULL)
   \   00000090   0x0010             MOVS     R0,R2
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD003             BEQ.N    ??LPLD_GPIO_Init_13
    114              GPIO_ISR[i] = isr_func;
   \   00000096   0x....             LDR.N    R0,??DataTable9_12
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0xF840 0x2025      STR      R2,[R0, R5, LSL #+2]
    115            
    116            return 1;
   \                     ??LPLD_GPIO_Init_13: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \                     ??LPLD_GPIO_Init_9: (+1)
   \   000000A0   0xBCF0             POP      {R4-R7}
   \   000000A2   0xB004             ADD      SP,SP,#+16
   \   000000A4   0x4770             BX       LR               ;; return
    117          }
    118          
    119          /*
    120           * LPLD_GPIO_EnableIrq
    121           * 使能GPIO外部中断
    122           * 
    123           * 参数:
    124           *    gpio_init_structure--GPIO初始化结构体，
    125           *                        具体定义见GPIO_InitTypeDef
    126           *
    127           * 输出:
    128           *    0--配置错误
    129           *    1--配置成功
    130           *
    131           */

   \                                 In section .text, align 2, keep-with-next
    132          uint8 LPLD_GPIO_EnableIrq(GPIO_InitTypeDef gpio_init_structure)
    133          {
   \                     LPLD_GPIO_EnableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    134            uint8 i;
    135            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9802             LDR      R0,[SP, #+8]
    136            
    137            //参数检查
    138            ASSERT( ptx <= PTE);                  //判断端口
    139            
    140            if(ptx == PTA)
   \   00000006   0x....             LDR.N    R1,??DataTable9_2  ;; 0x400ff000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_0
    141              i = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00F             B.N      ??LPLD_GPIO_EnableIrq_1
    142            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_EnableIrq_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ff040
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_2
    143              i = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00A             B.N      ??LPLD_GPIO_EnableIrq_1
    144            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_EnableIrq_2: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable9_6  ;; 0x400ff080
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_3
    145              i = 2;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE005             B.N      ??LPLD_GPIO_EnableIrq_1
    146            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_EnableIrq_3: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable9_8  ;; 0x400ff0c0
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_4
    147              i = 3;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE000             B.N      ??LPLD_GPIO_EnableIrq_1
    148            else
    149              i = 4;
   \                     ??LPLD_GPIO_EnableIrq_4: (+1)
   \   0000002E   0x2004             MOVS     R0,#+4
    150          
    151            enable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_EnableIrq_1: (+1)
   \   00000030   0x3057             ADDS     R0,R0,#+87
   \   00000032   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       NVIC_EnableIRQ
    152            
    153            return 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBC02             POP      {R1}
   \   0000003C   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    154          }
    155          
    156          /*
    157           * LPLD_GPIO_DisableIrq
    158           * 禁用GPIO外部中断
    159           * 
    160           * 参数:
    161           *    gpio_init_structure--GPIO初始化结构体，
    162           *                        具体定义见GPIO_InitTypeDef
    163           *
    164           * 输出:
    165           *    0--配置错误
    166           *    1--配置成功
    167           *
    168           */

   \                                 In section .text, align 2, keep-with-next
    169          uint8 LPLD_GPIO_DisableIrq(GPIO_InitTypeDef gpio_init_structure)
    170          {
   \                     LPLD_GPIO_DisableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    171            uint8 i;
    172            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9802             LDR      R0,[SP, #+8]
    173            
    174            //参数检查
    175            ASSERT( ptx <= PTE);                  //判断端口
    176            
    177            if(ptx == PTA)
   \   00000006   0x....             LDR.N    R1,??DataTable9_2  ;; 0x400ff000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_0
    178              i = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00F             B.N      ??LPLD_GPIO_DisableIrq_1
    179            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_DisableIrq_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ff040
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_2
    180              i = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00A             B.N      ??LPLD_GPIO_DisableIrq_1
    181            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_DisableIrq_2: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable9_6  ;; 0x400ff080
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_3
    182              i = 2;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE005             B.N      ??LPLD_GPIO_DisableIrq_1
    183            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_DisableIrq_3: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable9_8  ;; 0x400ff0c0
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_4
    184              i = 3;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE000             B.N      ??LPLD_GPIO_DisableIrq_1
    185            else
    186              i = 4;
   \                     ??LPLD_GPIO_DisableIrq_4: (+1)
   \   0000002E   0x2004             MOVS     R0,#+4
    187            
    188            disable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_DisableIrq_1: (+1)
   \   00000030   0x3057             ADDS     R0,R0,#+87
   \   00000032   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       NVIC_DisableIRQ
    189            
    190            return 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBC02             POP      {R1}
   \   0000003C   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    191          }
    192          
    193          /*
    194           * LPLD_GPIO_Ouptut
    195           * 设置GPIO端口0~31位的输出
    196           * 
    197           * 参数:
    198           *    ptx--端口号
    199           *      |__PTA        --Port A
    200           *      |__PTB        --Port B
    201           *      |__PTC        --Port C
    202           *      |__PTD        --Port D
    203           *      |__PTE        --Port E
    204           *    data32--输出数据
    205           *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位数据
    206           *
    207           * 输出:
    208           *
    209           */

   \                                 In section .text, align 2, keep-with-next
    210          __INLINE void LPLD_GPIO_Output(GPIO_Type *ptx, uint32 data32)
    211          { 
    212            ptx->PDOR = data32;
   \                     LPLD_GPIO_Output: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    213          }
   \   00000002   0x4770             BX       LR               ;; return
    214          
    215          /*
    216           * LPLD_GPIO_Ouptut_b
    217           * 设置GPIO端口一位的输出
    218           * 
    219           * 参数:
    220           *    ptx--端口号
    221           *      |__PTA        --Port A
    222           *      |__PTB        --Port B
    223           *      |__PTC        --Port C
    224           *      |__PTD        --Port D
    225           *      |__PTE        --Port E
    226           *    lsb_num--端口引脚位数编号
    227           *      |__0~31       --GPIO口的第0~31位
    228           *    data1--输出数据
    229           *      |__0          --输出低电平
    230           *      |__1          --输出高电平
    231           *
    232           * 输出:
    233           *
    234           */

   \                                 In section .text, align 2, keep-with-next
    235          __INLINE void LPLD_GPIO_Output_b(GPIO_Type *ptx, uint32 lsb_num, uint8 data1)
    236          {
   \                     LPLD_GPIO_Output_b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    237            ptx->PDOR = (ptx->PDOR & ~(0x01L<<lsb_num)) | (uint32)data1<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x6001             STR      R1,[R0, #+0]
    238          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    239          
    240          /*
    241           * LPLD_GPIO_Ouptut_8b
    242           * 设置GPIO端口8位的输出
    243           * 
    244           * 参数:
    245           *    ptx--端口号
    246           *      |__PTA        --Port A
    247           *      |__PTB        --Port B
    248           *      |__PTC        --Port C
    249           *      |__PTD        --Port D
    250           *      |__PTE        --Port E
    251           *    lsb_num--代表8个端口引脚的最低位数编号
    252           *      |__0~24       --GPIO口的第0~24位
    253           *    data8--输出数据
    254           *      |__0x00~0xFF--代表GPIO口输出的8位数据
    255           *
    256           * 输出:
    257           *
    258           */

   \                                 In section .text, align 2, keep-with-next
    259          __INLINE void LPLD_GPIO_Output_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    260          {
   \                     LPLD_GPIO_Output_8b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    261            ptx->PDOR = (ptx->PDOR & ~(0xFFL<<lsb_num)) | (uint32)data8<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x24FF             MOVS     R4,#+255
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x6001             STR      R1,[R0, #+0]
    262          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    263          
    264          /*
    265           * LPLD_GPIO_Toggle
    266           * 设置GPIO端口0~31的电平翻转
    267           * 
    268           * 参数:
    269           *    ptx--端口号
    270           *      |__PTA        --Port A
    271           *      |__PTB        --Port B
    272           *      |__PTC        --Port C
    273           *      |__PTD        --Port D
    274           *      |__PTE        --Port E
    275           *    data32--翻转数据
    276           *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位的翻转，1为反转，0为保持不变。
    277           *
    278           * 输出:
    279           *
    280           */

   \                                 In section .text, align 2, keep-with-next
    281          __INLINE void LPLD_GPIO_Toggle(GPIO_Type *ptx, uint32 data32)
    282          {  
    283            ptx->PTOR = data32;
   \                     LPLD_GPIO_Toggle: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
    284          }
   \   00000002   0x4770             BX       LR               ;; return
    285          
    286          /*
    287           * LPLD_GPIO_Toggle_b
    288           * 设置GPIO端口一位的翻转
    289           * 
    290           * 参数:
    291           *    ptx--端口号
    292           *      |__PTA        --Port A
    293           *      |__PTB        --Port B
    294           *      |__PTC        --Port C
    295           *      |__PTD        --Port D
    296           *      |__PTE        --Port E
    297           *    lsb_num--端口引脚位数编号
    298           *      |__0~31       --GPIO口的第0~31位
    299           *
    300           * 输出:
    301           *
    302           */

   \                                 In section .text, align 2, keep-with-next
    303          __INLINE void LPLD_GPIO_Toggle_b(GPIO_Type *ptx, uint8 lsb_num)
    304          {  
    305            ptx->PTOR = 0x01L<<lsb_num;
   \                     LPLD_GPIO_Toggle_b: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    306          }
   \   00000008   0x4770             BX       LR               ;; return
    307          
    308          /*
    309           * LPLD_GPIO_Toggle_8b
    310           * 设置GPIO端口8位的翻转
    311           * 
    312           * 参数:
    313           *    ptx--端口号
    314           *      |__PTA        --Port A
    315           *      |__PTB        --Port B
    316           *      |__PTC        --Port C
    317           *      |__PTD        --Port D
    318           *      |__PTE        --Port E
    319           *    lsb_num--代表8个端口引脚的最低位数编号
    320           *      |__0~24       --GPIO口的第0~24位
    321           *    data8--输出数据
    322           *      |__0x00~0xFF--代表GPIO口输出的8位数据
    323           *
    324           * 输出:
    325           *
    326           */

   \                                 In section .text, align 2, keep-with-next
    327          __INLINE void LPLD_GPIO_Toggle_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    328          {
    329            ptx->PTOR = (uint32)data8<<lsb_num;
   \                     LPLD_GPIO_Toggle_8b: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    330          }
   \   00000008   0x4770             BX       LR               ;; return
    331          
    332          /*
    333           * LPLD_GPIO_Input
    334           * 取得GPIO口0~31位的数据
    335           * 
    336           * 参数:
    337           *    ptx--端口号
    338           *      |__PTA        --Port A
    339           *      |__PTB        --Port B
    340           *      |__PTC        --Port C
    341           *      |__PTD        --Port D
    342           *      |__PTE        --Port E
    343           *
    344           * 输出:
    345           *    指定GPIO口的32位输入
    346           *
    347           */

   \                                 In section .text, align 2, keep-with-next
    348          __INLINE uint32 LPLD_GPIO_Input(GPIO_Type *ptx)
    349          {
    350            return ptx->PDIR;
   \                     LPLD_GPIO_Input: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    351          }
    352          
    353          /*
    354           * LPLD_GPIO_Input_b
    355           * 取得GPIO口某一位的数据
    356           * 
    357           * 参数:
    358           *    ptx--端口号
    359           *      |__PTA        --Port A
    360           *      |__PTB        --Port B
    361           *      |__PTC        --Port C
    362           *      |__PTD        --Port D
    363           *      |__PTE        --Port E
    364           *    lsb_num--端口引脚位数编号
    365           *      |__0~31       --GPIO口的第0~31位
    366           *
    367           * 输出:
    368           *    指定GPIO口的指定位数的电平
    369           *
    370           */

   \                                 In section .text, align 2, keep-with-next
    371          __INLINE uint8 LPLD_GPIO_Input_b(GPIO_Type *ptx, uint8 lsb_num)
    372          {  
    373            return (uint8)((ptx->PDIR>>lsb_num)&0x01L);
   \                     LPLD_GPIO_Input_b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /*
    377           * LPLD_GPIO_Input_8b
    378           * 取得GPIO端口8位数据的输入
    379           * 
    380           * 参数:
    381           *    ptx--端口号
    382           *      |__PTA        --Port A
    383           *      |__PTB        --Port B
    384           *      |__PTC        --Port C
    385           *      |__PTD        --Port D
    386           *      |__PTE        --Port E
    387           *    lsb_num--代表8个端口引脚的最低位数编号
    388           *      |__0~24       --GPIO口的第0~24位
    389           *
    390           * 输出:
    391           *    指定GPIO口的8位数据的电平
    392           *
    393           */

   \                                 In section .text, align 2, keep-with-next
    394          __INLINE uint8 LPLD_GPIO_Input_8b(GPIO_Type *ptx, uint8 lsb_num)
    395          {
    396            return (uint8)((ptx->PDIR>>lsb_num)&0xFFL);
   \                     LPLD_GPIO_Input_8b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4770             BX       LR               ;; return
    397          }
    398          
    399          /*
    400           * PORTA--PORTE中断处理函数
    401           * 与启动文件startup_K60.s中的中断向量表关联
    402           * 用户无需修改，程序自动进入对应通道中断函数
    403           */

   \                                 In section .text, align 2, keep-with-next
    404          void PORTA_IRQHandler(void)
    405          {
   \                     PORTA_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    406          #if (UCOS_II > 0u)
    407            OS_CPU_SR  cpu_sr = 0u;
    408            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    409            OSIntEnter();
    410            OS_EXIT_CRITICAL();
    411          #endif
    412            
    413            //调用用户自定义中断服务
    414            GPIO_ISR[0](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    415            PORTA->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_13  ;; 0x400490a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    416            
    417          #if (UCOS_II > 0u)
    418            OSIntExit();          //告知系统此时即将离开中断服务子函数
    419          #endif
    420          }//           ;87:  PORT A interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    421          

   \                                 In section .text, align 2, keep-with-next
    422          void PORTB_IRQHandler(void)
    423          {
   \                     PORTB_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    424          #if (UCOS_II > 0u)
    425            OS_CPU_SR  cpu_sr = 0u;
    426            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    427            OSIntEnter();
    428            OS_EXIT_CRITICAL();
    429          #endif
    430            
    431            //调用用户自定义中断服务
    432            GPIO_ISR[1](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x4780             BLX      R0
    433            PORTB->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_14  ;; 0x4004a0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    434            
    435          #if (UCOS_II > 0u)
    436            OSIntExit();          //告知系统此时即将离开中断服务子函数
    437          #endif
    438          }//           ;88:  PORT B interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    439          

   \                                 In section .text, align 2, keep-with-next
    440          void PORTC_IRQHandler(void)
    441          {
   \                     PORTC_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    442          #if (UCOS_II > 0u)
    443            OS_CPU_SR  cpu_sr = 0u;
    444            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    445            OSIntEnter();
    446            OS_EXIT_CRITICAL();
    447          #endif
    448            
    449            //调用用户自定义中断服务
    450            GPIO_ISR[2](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x4780             BLX      R0
    451            PORTC->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_15  ;; 0x4004b0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    452            
    453          #if (UCOS_II > 0u)
    454            OSIntExit();          //告知系统此时即将离开中断服务子函数
    455          #endif
    456          }//           ;89:  PORT C interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    457          

   \                                 In section .text, align 2, keep-with-next
    458          void PORTD_IRQHandler(void)
    459          {
   \                     PORTD_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    460          #if (UCOS_II > 0u)
    461            OS_CPU_SR  cpu_sr = 0u;
    462            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    463            OSIntEnter();
    464            OS_EXIT_CRITICAL();
    465          #endif
    466            
    467            //调用用户自定义中断服务
    468            GPIO_ISR[3](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x4780             BLX      R0
    469            PORTD->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_16  ;; 0x4004c0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    470            
    471          #if (UCOS_II > 0u)
    472            OSIntExit();          //告知系统此时即将离开中断服务子函数
    473          #endif
    474          }//           ;90:  PORT D interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    475          

   \                                 In section .text, align 2, keep-with-next
    476          void PORTE_IRQHandler(void)
    477          {
   \                     PORTE_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    478          #if (UCOS_II > 0u)
    479            OS_CPU_SR  cpu_sr = 0u;
    480            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    481            OSIntEnter();
    482            OS_EXIT_CRITICAL();
    483          #endif
    484            
    485            //调用用户自定义中断服务
    486            GPIO_ISR[4](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6900             LDR      R0,[R0, #+16]
   \   00000006   0x4780             BLX      R0
    487            PORTE->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_17  ;; 0x4004d0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    488            
    489          #if (UCOS_II > 0u)
    490            OSIntExit();          //告知系统此时即将离开中断服务子函数
    491          #endif
    492          }//           ;91:  PORT E interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     GPIO_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   LPLD_GPIO_DisableIrq
        24   -> NVIC_DisableIRQ
      24   LPLD_GPIO_EnableIrq
        24   -> NVIC_EnableIRQ
      32   LPLD_GPIO_Init
       0   LPLD_GPIO_Input
       0   LPLD_GPIO_Input_8b
       0   LPLD_GPIO_Input_b
       0   LPLD_GPIO_Output
       4   LPLD_GPIO_Output_8b
       4   LPLD_GPIO_Output_b
       0   LPLD_GPIO_Toggle
       0   LPLD_GPIO_Toggle_8b
       0   LPLD_GPIO_Toggle_b
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   PORTA_IRQHandler
         8   -- Indirect call
       8   PORTB_IRQHandler
         8   -- Indirect call
       8   PORTC_IRQHandler
         8   -- Indirect call
       8   PORTD_IRQHandler
         8   -- Indirect call
       8   PORTE_IRQHandler
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      20  GPIO_ISR
      64  LPLD_GPIO_DisableIrq
      64  LPLD_GPIO_EnableIrq
     166  LPLD_GPIO_Init
       4  LPLD_GPIO_Input
       8  LPLD_GPIO_Input_8b
      10  LPLD_GPIO_Input_b
       4  LPLD_GPIO_Output
      24  LPLD_GPIO_Output_8b
      24  LPLD_GPIO_Output_b
       4  LPLD_GPIO_Toggle
      10  LPLD_GPIO_Toggle_8b
      10  LPLD_GPIO_Toggle_b
      20  NVIC_DisableIRQ
      20  NVIC_EnableIRQ
      18  PORTA_IRQHandler
      18  PORTB_IRQHandler
      18  PORTC_IRQHandler
      18  PORTD_IRQHandler
      18  PORTE_IRQHandler

 
  20 bytes in section .bss
 594 bytes in section .text
 
 594 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
